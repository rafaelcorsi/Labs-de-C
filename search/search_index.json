{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo aos Laborat\u00f3rios de C \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados Objetivos \u00b6 Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper. Motiva\u00e7\u00e3o \u00b6 C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel Pesquisa \u00b6 MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Home"},{"location":"#bem-vindo-aos-laboratorios-de-c","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados","title":"Bem vindo aos Laborat\u00f3rios de C"},{"location":"#objetivos","text":"Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper.","title":"Objetivos"},{"location":"#motivacao","text":"C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel","title":"Motiva\u00e7\u00e3o"},{"location":"#pesquisa","text":"MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Pesquisa"},{"location":"Lab1/","text":"Lab 1 - Conceitos B\u00e1sicos \u00b6 Note Por favor, fa\u00e7am esta atividade em dupla . Note Esse laborat\u00f3rio deve ser realizado com a mesma infra do day-one: AtmelStudio, kit de desenvolvimento de embarcados e LCD. Introdu\u00e7\u00e3o \u00b6 N\u00e3o \u00e9 f\u00e1cil prever o quanto a linguagem C ser\u00e1 uma novidade para voc\u00eas. Por um lado, a sintaxe \u00e9 muito parecida com Java. Por outro lado, existem diferen\u00e7as importantes e voc\u00eas est\u00e3o longe de Java h\u00e1 mais ou menos meio semestre... Vamos come\u00e7ar com a revis\u00e3o de alguns conceitos bem b\u00e1sicos. Procure, mais ou menos na metade do arquivo main.c , a fun\u00e7\u00e3o process_pixel . int process_pixel ( int level ) { int new_level ; new_level = level ; return new_level ; } Essa fun\u00e7\u00e3o \u00e9 trivial, mas no c\u00f3digo j\u00e1 vemos v\u00e1rios conceitos importantes: as instru\u00e7\u00f5es terminam em ponto-e-v\u00edrgula, como em Java; new_level \u00e9 uma vari\u00e1vel da fun\u00e7\u00e3o e precisa ser declarada para poder ser usada, como em Java; valores e vari\u00e1veis possuem tipo , pois C \u00e9 uma linguagem com tipagem forte , como Java; a declara\u00e7\u00e3o de uma vari\u00e1vel segue a sintaxe tipo nome , como em Java; int \u00e9 o tipo que representa n\u00fameros inteiros, como em Java; como tipagem forte significa que tudo , sem exce\u00e7\u00e3o, tem tipo, int tamb\u00e9m aparece antes da declara\u00e7\u00e3o do par\u00e2metro level , indicando que esse par\u00e2metro \u00e9 um n\u00famero inteiro, e antes do pr\u00f3prio nome da fun\u00e7\u00e3o, indicando que process_pixel devolve um n\u00famero inteiro; essa devolu\u00e7\u00e3o, ali\u00e1s, \u00e9 feita atrav\u00e9s da instru\u00e7\u00e3o return , como em Python e Java; tamb\u00e9m em comum com Python e Java, temos o operador = de atribui\u00e7\u00e3o. Na verdade, soa um pouco injusto ficar dizendo \"como em Java\" e \"como em Python\", pois na verdade C veio antes de ambas! Enfim, mesmo com a ferrugem p\u00f3s-f\u00e9rias, voc\u00eas j\u00e1 devem ter percebido que essa fant\u00e1stica fun\u00e7\u00e3o faz... nada de \u00fatil. Ela apenas copia o valor do par\u00e2metro level para a vari\u00e1vel new_level e devolve o valor de new_level . Em outras palavras, apenas devolve o valor original de level , sem fazer nenhum tipo de processamento. Yay! Vejamos o contexto no qual essa fun\u00e7\u00e3o est\u00e1 sendo chamada. #ifdef PARTE3 for ( int y = 0 ; y < IMG_HEIGHT ; y ++ ) { for ( int x = 0 ; x < IMG_HEIGHT ; x ++ ) { imgOut [ y ][ x ] = process_pixel ( imgIn [ y ][ x ]); } } #endif Hoje voc\u00eas n\u00e3o precisam saber todos os detalhes desse c\u00f3digo (isso acontecer\u00e1 na primeira aula de quarta), apenas que esses loops substituem o valor original de cada pixel da imagem pelo resultado devolvido por process_pixel , calculado a partir desse valor original. Como acabamos de ver que a fun\u00e7\u00e3o simplesmente devolve o mesmo valor, ent\u00e3o a imagem permanece inalterada. Vamos fazer algo mais interessante? Exerc\u00edcios Preliminares \u00b6 Para todos os exerc\u00edcios deste handout, sigam por favor as regras abaixo. Todos os enunciados dizem \"o que\" a fun\u00e7\u00e3o deve fazer, mas n\u00e3o dizem \"como\" ela deve fazer. Essa restri\u00e7\u00e3o \u00e9 proposital! N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo. Example O valor de um pixel \u00e9 um n\u00famero inteiro entre 0 e 255 . Quanto mais alto o valor, mais claro \u00e9 o pixel. Sabendo disso, altere process_pixel para negativizar a imagem, ou seja, transformar pixels claros em escuros e vice-versa. Example Agora altere process_pixel para escurecer a imagem: cada pixel deve ficar com a metade de sua luminosidade original. Antes do pr\u00f3ximo exerc\u00edcio, uma dica! A sintaxe de if/else em C, para variar, \u00e9 como em Java. Ou seja: if ( condi\u00e7\u00e3o ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } else { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } Sabendo disso... Example Altere process_pixel para receber um segundo par\u00e2metro, tamb\u00e9m inteiro, e limiarizar a imagem: se o valor original do pixel for menor que esse segundo par\u00e2metro, seu novo valor deve ser 0 (preto); se o valor original do pixel for maior ou igual que esse segundo par\u00e2metro, seu novo valor deve ser 255 (branco). N\u00e3o esque\u00e7a de alterar o trecho de c\u00f3digo em que process_pixel \u00e9 chamada, para evitar erros de compila\u00e7\u00e3o. Passe 127 como o segundo par\u00e2metro da chamada. Example Altere process_pixel para manipular o brilho da imagem: use o segundo par\u00e2metro, adicionado no exerc\u00edcio anterior, como um valor que \u00e9 somado ao pixel. Fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Example Altere process_pixel para manipular o contraste da imagem: use o segundo par\u00e2metro como um valor que multiplica o pixel. Novamente, fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Nesses exerc\u00edcios preliminares, voc\u00eas j\u00e1 usaram os operadores aritm\u00e9ticos b\u00e1sicos ( + , - , / , * ), execu\u00e7\u00e3o condicional ( if/else ) e a estrutura b\u00e1sica de fun\u00e7\u00f5es. Agora vamos sair do Atmel! Exerc\u00edcios Intermedi\u00e1rios \u00b6 Lembrete: Para cada quest\u00e3o, validar a resposta com um dos professores antes de continuar para a pr\u00f3xima. Ali\u00e1s, n\u00e3o apenas do Atmel... vamos sair do computador por alguns instantes e fazer os pr\u00f3ximos exerc\u00edcios no papel. \u00c9 muito importante que, pelo menos nesse come\u00e7o, voc\u00ea n\u00e3o fique excessivamente dependente do computador e da IDE. Saiba fazer pelo menos o b\u00e1sico sozinho, pois isso faz muita diferen\u00e7a na produtividade. Question Como esperado, a sintaxe de while em C tamb\u00e9m \u00e9 como em Java. Sabendo disso, considere o c\u00f3digo abaixo, que calcula a soma dos n\u00fameros de 1 a 10 . int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Ou melhor, que deveria calcular a soma dos n\u00fameros de 1 a 10 . Qual \u00e9 o problema com esse c\u00f3digo? Reescreva o c\u00f3digo, evitando os tr\u00eas problemas acima. Solu\u00e7\u00e3o Podemos identificar no c\u00f3digo os tr\u00eas problemas abaixo. A vari\u00e1vel s n\u00e3o \u00e9 inicializada. Em Java, o valor padr\u00e3o de uma vari\u00e1vel int \u00e9 0 , mas em C essa garantia n\u00e3o existe! De fato, uma vari\u00e1vel em C \u00e9 inicializada com lixo de mem\u00f3ria , ou seja, um valor baseado nos bits que j\u00e1 estavam escritos no peda\u00e7o de mem\u00f3ria que foi reservado para a vari\u00e1vel. Esses bits s\u00e3o totalmente imprevis\u00edveis! Se a condi\u00e7\u00e3o do while \u00e9 i < 10 , ent\u00e3o o \u00faltimo valor de i somado a s \u00e9 9 e n\u00e3o 10 . A soma est\u00e1 incompleta! A vari\u00e1vel i deveria ter sido inicializada com o valor 1 . A rigor, esse problema n\u00e3o torna o c\u00f3digo incorreto , pois a soma de 0 \u00e9 in\u00f3cua, mas torna o c\u00f3digo ineficiente , pois uma itera\u00e7\u00e3o \u00e9 desperdi\u00e7ada. Question Considere agora o c\u00f3digo abaixo, que deveria calcular a metade da soma dos n\u00fameros de 1 a 10 . int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Qual \u00e9 o problema com esse c\u00f3digo? Solu\u00e7\u00e3o Quando os dois par\u00e2metros do operador / s\u00e3o inteiros, o resultado tamb\u00e9m \u00e9 um inteiro. Se a divis\u00e3o n\u00e3o for exata, a parte fracion\u00e1ria \u00e9 truncada . Isso significa que o que deveria ser a soma de 0.5 , 1 , 1.5 , 2 , 2.5 , etc. \u00e9 na verdade a soma de 0 , 1 , 1 , 2 , 2 , etc. Para resolver isso, precisamos primeiramente declarar s como double , permitindo a essa vari\u00e1vel representar n\u00fameros reais... adivinhem... como em Java. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Mas isso n\u00e3o \u00e9 suficiente! N\u00e3o adianta s poder armazenar reais se o que ela recebe de / s\u00e3o inteiros. Precisamos tamb\u00e9m garantir que / devolve um real, e isso acontece se pelo menos um dos dois n\u00fameros envolvidos na divis\u00e3o \u00e9 reconhecido como real. Existem duas maneiras simples de conseguir esse reconhecimento. O primeiro \u00e9 simplesmente substituir 2 por 2.0 . A exist\u00eancia de uma parte fracion\u00e1ria, mesmo sendo zero, simboliza que o n\u00famero \u00e9 real. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2.0 ; i ++ ; } O segundo \u00e9 fazer um casting de i para double antes da divis\u00e3o. Lembram do conceito de casting? Significa pedir para o programa interpretar uma vari\u00e1vel como sendo de certo tipo. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += ( double ) i / 2 ; i ++ ; } Note que um casting de int para double \u00e9 praticamente in\u00f3cuo, mas no casting de double para int perde-se a informa\u00e7\u00e3o fracion\u00e1ria.","title":"Lab 1 - Conceitos B\u00e1sicos"},{"location":"Lab1/#lab-1-conceitos-basicos","text":"Note Por favor, fa\u00e7am esta atividade em dupla . Note Esse laborat\u00f3rio deve ser realizado com a mesma infra do day-one: AtmelStudio, kit de desenvolvimento de embarcados e LCD.","title":"Lab 1 - Conceitos B\u00e1sicos"},{"location":"Lab1/#introducao","text":"N\u00e3o \u00e9 f\u00e1cil prever o quanto a linguagem C ser\u00e1 uma novidade para voc\u00eas. Por um lado, a sintaxe \u00e9 muito parecida com Java. Por outro lado, existem diferen\u00e7as importantes e voc\u00eas est\u00e3o longe de Java h\u00e1 mais ou menos meio semestre... Vamos come\u00e7ar com a revis\u00e3o de alguns conceitos bem b\u00e1sicos. Procure, mais ou menos na metade do arquivo main.c , a fun\u00e7\u00e3o process_pixel . int process_pixel ( int level ) { int new_level ; new_level = level ; return new_level ; } Essa fun\u00e7\u00e3o \u00e9 trivial, mas no c\u00f3digo j\u00e1 vemos v\u00e1rios conceitos importantes: as instru\u00e7\u00f5es terminam em ponto-e-v\u00edrgula, como em Java; new_level \u00e9 uma vari\u00e1vel da fun\u00e7\u00e3o e precisa ser declarada para poder ser usada, como em Java; valores e vari\u00e1veis possuem tipo , pois C \u00e9 uma linguagem com tipagem forte , como Java; a declara\u00e7\u00e3o de uma vari\u00e1vel segue a sintaxe tipo nome , como em Java; int \u00e9 o tipo que representa n\u00fameros inteiros, como em Java; como tipagem forte significa que tudo , sem exce\u00e7\u00e3o, tem tipo, int tamb\u00e9m aparece antes da declara\u00e7\u00e3o do par\u00e2metro level , indicando que esse par\u00e2metro \u00e9 um n\u00famero inteiro, e antes do pr\u00f3prio nome da fun\u00e7\u00e3o, indicando que process_pixel devolve um n\u00famero inteiro; essa devolu\u00e7\u00e3o, ali\u00e1s, \u00e9 feita atrav\u00e9s da instru\u00e7\u00e3o return , como em Python e Java; tamb\u00e9m em comum com Python e Java, temos o operador = de atribui\u00e7\u00e3o. Na verdade, soa um pouco injusto ficar dizendo \"como em Java\" e \"como em Python\", pois na verdade C veio antes de ambas! Enfim, mesmo com a ferrugem p\u00f3s-f\u00e9rias, voc\u00eas j\u00e1 devem ter percebido que essa fant\u00e1stica fun\u00e7\u00e3o faz... nada de \u00fatil. Ela apenas copia o valor do par\u00e2metro level para a vari\u00e1vel new_level e devolve o valor de new_level . Em outras palavras, apenas devolve o valor original de level , sem fazer nenhum tipo de processamento. Yay! Vejamos o contexto no qual essa fun\u00e7\u00e3o est\u00e1 sendo chamada. #ifdef PARTE3 for ( int y = 0 ; y < IMG_HEIGHT ; y ++ ) { for ( int x = 0 ; x < IMG_HEIGHT ; x ++ ) { imgOut [ y ][ x ] = process_pixel ( imgIn [ y ][ x ]); } } #endif Hoje voc\u00eas n\u00e3o precisam saber todos os detalhes desse c\u00f3digo (isso acontecer\u00e1 na primeira aula de quarta), apenas que esses loops substituem o valor original de cada pixel da imagem pelo resultado devolvido por process_pixel , calculado a partir desse valor original. Como acabamos de ver que a fun\u00e7\u00e3o simplesmente devolve o mesmo valor, ent\u00e3o a imagem permanece inalterada. Vamos fazer algo mais interessante?","title":"Introdu\u00e7\u00e3o"},{"location":"Lab1/#exercicios-preliminares","text":"Para todos os exerc\u00edcios deste handout, sigam por favor as regras abaixo. Todos os enunciados dizem \"o que\" a fun\u00e7\u00e3o deve fazer, mas n\u00e3o dizem \"como\" ela deve fazer. Essa restri\u00e7\u00e3o \u00e9 proposital! N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo. Example O valor de um pixel \u00e9 um n\u00famero inteiro entre 0 e 255 . Quanto mais alto o valor, mais claro \u00e9 o pixel. Sabendo disso, altere process_pixel para negativizar a imagem, ou seja, transformar pixels claros em escuros e vice-versa. Example Agora altere process_pixel para escurecer a imagem: cada pixel deve ficar com a metade de sua luminosidade original. Antes do pr\u00f3ximo exerc\u00edcio, uma dica! A sintaxe de if/else em C, para variar, \u00e9 como em Java. Ou seja: if ( condi\u00e7\u00e3o ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } else { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } Sabendo disso... Example Altere process_pixel para receber um segundo par\u00e2metro, tamb\u00e9m inteiro, e limiarizar a imagem: se o valor original do pixel for menor que esse segundo par\u00e2metro, seu novo valor deve ser 0 (preto); se o valor original do pixel for maior ou igual que esse segundo par\u00e2metro, seu novo valor deve ser 255 (branco). N\u00e3o esque\u00e7a de alterar o trecho de c\u00f3digo em que process_pixel \u00e9 chamada, para evitar erros de compila\u00e7\u00e3o. Passe 127 como o segundo par\u00e2metro da chamada. Example Altere process_pixel para manipular o brilho da imagem: use o segundo par\u00e2metro, adicionado no exerc\u00edcio anterior, como um valor que \u00e9 somado ao pixel. Fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Example Altere process_pixel para manipular o contraste da imagem: use o segundo par\u00e2metro como um valor que multiplica o pixel. Novamente, fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Nesses exerc\u00edcios preliminares, voc\u00eas j\u00e1 usaram os operadores aritm\u00e9ticos b\u00e1sicos ( + , - , / , * ), execu\u00e7\u00e3o condicional ( if/else ) e a estrutura b\u00e1sica de fun\u00e7\u00f5es. Agora vamos sair do Atmel!","title":"Exerc\u00edcios Preliminares"},{"location":"Lab1/#exercicios-intermediarios","text":"Lembrete: Para cada quest\u00e3o, validar a resposta com um dos professores antes de continuar para a pr\u00f3xima. Ali\u00e1s, n\u00e3o apenas do Atmel... vamos sair do computador por alguns instantes e fazer os pr\u00f3ximos exerc\u00edcios no papel. \u00c9 muito importante que, pelo menos nesse come\u00e7o, voc\u00ea n\u00e3o fique excessivamente dependente do computador e da IDE. Saiba fazer pelo menos o b\u00e1sico sozinho, pois isso faz muita diferen\u00e7a na produtividade. Question Como esperado, a sintaxe de while em C tamb\u00e9m \u00e9 como em Java. Sabendo disso, considere o c\u00f3digo abaixo, que calcula a soma dos n\u00fameros de 1 a 10 . int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Ou melhor, que deveria calcular a soma dos n\u00fameros de 1 a 10 . Qual \u00e9 o problema com esse c\u00f3digo? Reescreva o c\u00f3digo, evitando os tr\u00eas problemas acima. Solu\u00e7\u00e3o Podemos identificar no c\u00f3digo os tr\u00eas problemas abaixo. A vari\u00e1vel s n\u00e3o \u00e9 inicializada. Em Java, o valor padr\u00e3o de uma vari\u00e1vel int \u00e9 0 , mas em C essa garantia n\u00e3o existe! De fato, uma vari\u00e1vel em C \u00e9 inicializada com lixo de mem\u00f3ria , ou seja, um valor baseado nos bits que j\u00e1 estavam escritos no peda\u00e7o de mem\u00f3ria que foi reservado para a vari\u00e1vel. Esses bits s\u00e3o totalmente imprevis\u00edveis! Se a condi\u00e7\u00e3o do while \u00e9 i < 10 , ent\u00e3o o \u00faltimo valor de i somado a s \u00e9 9 e n\u00e3o 10 . A soma est\u00e1 incompleta! A vari\u00e1vel i deveria ter sido inicializada com o valor 1 . A rigor, esse problema n\u00e3o torna o c\u00f3digo incorreto , pois a soma de 0 \u00e9 in\u00f3cua, mas torna o c\u00f3digo ineficiente , pois uma itera\u00e7\u00e3o \u00e9 desperdi\u00e7ada. Question Considere agora o c\u00f3digo abaixo, que deveria calcular a metade da soma dos n\u00fameros de 1 a 10 . int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Qual \u00e9 o problema com esse c\u00f3digo? Solu\u00e7\u00e3o Quando os dois par\u00e2metros do operador / s\u00e3o inteiros, o resultado tamb\u00e9m \u00e9 um inteiro. Se a divis\u00e3o n\u00e3o for exata, a parte fracion\u00e1ria \u00e9 truncada . Isso significa que o que deveria ser a soma de 0.5 , 1 , 1.5 , 2 , 2.5 , etc. \u00e9 na verdade a soma de 0 , 1 , 1 , 2 , 2 , etc. Para resolver isso, precisamos primeiramente declarar s como double , permitindo a essa vari\u00e1vel representar n\u00fameros reais... adivinhem... como em Java. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Mas isso n\u00e3o \u00e9 suficiente! N\u00e3o adianta s poder armazenar reais se o que ela recebe de / s\u00e3o inteiros. Precisamos tamb\u00e9m garantir que / devolve um real, e isso acontece se pelo menos um dos dois n\u00fameros envolvidos na divis\u00e3o \u00e9 reconhecido como real. Existem duas maneiras simples de conseguir esse reconhecimento. O primeiro \u00e9 simplesmente substituir 2 por 2.0 . A exist\u00eancia de uma parte fracion\u00e1ria, mesmo sendo zero, simboliza que o n\u00famero \u00e9 real. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2.0 ; i ++ ; } O segundo \u00e9 fazer um casting de i para double antes da divis\u00e3o. Lembram do conceito de casting? Significa pedir para o programa interpretar uma vari\u00e1vel como sendo de certo tipo. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += ( double ) i / 2 ; i ++ ; } Note que um casting de int para double \u00e9 praticamente in\u00f3cuo, mas no casting de double para int perde-se a informa\u00e7\u00e3o fracion\u00e1ria.","title":"Exerc\u00edcios Intermedi\u00e1rios"},{"location":"Lab2/","text":"Lab 2 - Praticando \u00b6 Agora que praticamos um pouco no papel (de novo, habilidade fundamental para qualquer programador), vamos voltar ao computador, mas em um ambiente mais geral que o Atmel. Na verdade, o verdadeiro ambiente ser\u00e1 apresentado na leitura que passaremos para ter\u00e7a e na primeira aula de quarta, mas por enquanto vamos usar um mais simples, que n\u00e3o exige instala\u00e7\u00e3o. Entre no site https://www.onlinegdb.com/online_c_compiler . Como mencionado, esse ambiente \u00e9 muito simples: vamos apenas digitar o c\u00f3digo e rod\u00e1-lo atrav\u00e9s do bot\u00e3o verde \"Run\". Se o site estiver lento, tente esse outro: https://repl.it/ Warning Nesse exerc\u00edcio n\u00e3o \u00e9 necess\u00e1rio esperar a valida\u00e7\u00e3o de um professor. Vamos come\u00e7ar analisando o c\u00f3digo que j\u00e1 vem pronto no ambiente. #include <stdio.h> int main () { printf ( \"Hello World\" ); return 0 ; } Novamente, temos um c\u00f3digo curto mas com v\u00e1rios conceitos importantes: a fun\u00e7\u00e3o main equivale ao m\u00e9todo main em Java, ou seja, \u00e9 a fun\u00e7\u00e3o principal , chamada quando o programa \u00e9 rodado; diferente de Java, no entanto, essa fun\u00e7\u00e3o \u00e9 int em vez de void , pois devolve um c\u00f3digo que indica se o programa foi bem-sucedido ou n\u00e3o; por enquanto, consideraremos apenas a devolu\u00e7\u00e3o do c\u00f3digo 0 , que indica que o programa foi, sim, bem-sucedido; #include equivale ao import em Python e Java, ou seja, amplia o conjunto de funcionalidades que o programa pode usar; de fato, \u00e9 justamente por causa do #include <stdio.h> que o programa pode usar a fun\u00e7\u00e3o printf . printf corresponde \u00e0 System.out.print em Java, ou seja, \u00e9 a fun\u00e7\u00e3o respons\u00e1vel por imprimir texto no terminal. No entanto, existe uma diferen\u00e7a de uso entre a printf do C e a System.out.print do Java. O c\u00f3digo abaixo n\u00e3o vai funcionar. #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: \" + n + \", \" + m + \" \\n \" ); return 0 ; } A fun\u00e7\u00e3o printf usa um sistema de interpola\u00e7\u00e3o para exibir valores: #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: %d, %d \\n \" , n , m ); return 0 ; } O c\u00f3digo acima significa \"substitua as duas ocorr\u00eancias de %d pelos valores de n e m , pela ordem\". Parece complicado, mas note que na verdade \u00e9 uma sintaxe mais limpa que a do Java, sem a necessidade de ficar somando strings. O s\u00edmbolo a ser substitu\u00eddo \u00e9 sempre % seguido de letras que representam o tipo do valor. A letra d (de \"decimal\") representa int , enquanto as letras lf (de \"long float\") representam double . #include <stdio.h> int main () { double n = 1.2 ; double m = 2.1 ; printf ( \"Hello World: %lf, %lf\" , n , m ); return 0 ; } Antes de apresentar outros conceitos, vamos praticar um pouco no ambiente. Example int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a soma de 1 a 10 . Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado com printf() Example int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a metade da soma dos n\u00famereos de 1 a 10 Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado Vamos agora finalmente escrever um programa com intera\u00e7\u00e3o de usu\u00e1rio! #include <stdio.h> int main () { int n ; printf ( \"Digite um n\u00famero: \" ); scanf ( \"%d\" , & n ); printf ( \"O n\u00famero digitado \u00e9: %d \\n \" , n ); return 0 ; } Enquanto a fun\u00e7\u00e3o printf usa o s\u00edmbolo %d para indicar que quer \"escrever um inteiro\", a fun\u00e7\u00e3o scanf usa o s\u00edmbolo %d para indicar que quer \"ler um inteiro\". Note tamb\u00e9m uma diferen\u00e7a important\u00edssima entre printf e scanf : apenas no segundo h\u00e1 um & antes da vari\u00e1vel. Os detalhes t\u00e9cnicos disso ser\u00e3o revelados na segunda aula de quarta, mas por enquanto mantenha em mente que se voc\u00ea esquecer o & , o scanf n\u00e3o vai funcionar . Preparados para um exemplo mais avan\u00e7ado? O pr\u00f3ximo mostra de uma s\u00f3 vez: inclus\u00e3o de outra biblioteca al\u00e9m de stdio.h ; defini\u00e7\u00e3o de uma constante; implementa\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o pr\u00f3pria. #include <stdio.h> #include <math.h> #define PI 3.141592 void print_trigo ( int a ) { printf ( \"seno: %lf, cosseno: %lf \\n \" , sin ( a ), cos ( a )); } int main () { int angle ; printf ( \"Digite um \u00e2ngulo em graus: \" ); scanf ( \"%d\" , & angle ); print_trigo ( angle ); return 0 ; } Vejamos o que h\u00e1 de novo no c\u00f3digo: adicionamos #include <math.h> e, por causa disso, pudemos usar as fun\u00e7\u00f5es trigonom\u00e9tricas sin e cos para calcular seno e cosseno respectivamente; definimos a constante PI como sendo o real 3.141592 ; implementamos e chamamos a fun\u00e7\u00e3o print_trigo , que n\u00e3o precisa de return por ser do tipo void ; A diferen\u00e7a entre vari\u00e1veis e constantes \u00e9 que, enquanto uma vari\u00e1vel \u00e9... er... vari\u00e1vel, uma constante \u00e9... er... constante, ou seja, n\u00e3o pode ser alterada: o c\u00f3digo PI = 5 causaria um erro. Por falar em PI , reparou que definimos a constante mas nunca a usamos? Na verdade, n\u00e3o foi um acidente... Question Qual \u00e9 o problema no c\u00f3digo acima? A dica j\u00e1 est\u00e1 dada: para ser resolvido, precisamos usar PI ... Example Resolva o problema! N\u00e3o continue antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Exerc\u00edcios Avan\u00e7ados \u00b6 Mesmo que n\u00e3o d\u00ea tempo de fazer esses exerc\u00edcios em sala, \u00e9 muito importante que voc\u00ea os fa\u00e7a at\u00e9 quarta para desenferrujar programa\u00e7\u00e3o e praticar C. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro e devolve o m\u00f3dulo desse inteiro. Example Escreva uma fun\u00e7\u00e3o que recebe quatro inteiros, representando as coordenadas de dois pontos no plano cartesiano, e devolve a dist\u00e2ncia de Manhattan (pesquise) entre esses pontos. Voc\u00eas j\u00e1 fiazeram esse exerc\u00edcio em Desenvolvimento Colaborativo \u00c1gil . Assim como o for padr\u00e3o do Java, o for do C n\u00e3o funciona como o for do Python. Na verdade, \u00e9 apenas um \"a\u00e7\u00facar sint\u00e1tico\" que facilita a escrita de loops: for ( i = 0 ; i < 10 ; i ++ ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } equivale a i = 0 ; while ( i < 10 ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... i ++ ; } Em Java existe o enhanced for , que \u00e9 mais parecido com o for do Python, mas n\u00e3o existe uma equival\u00eancia disso em C. Bem-vindos ao baixo n\u00edvel! N\u00e3o temos bolo, mas temos os ingredientes para voc\u00ea fazer um bolo. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e, para cada inteiro i entre 1 e n , imprime uma string conforme a seguinte regra: \"nenhum\" se i n\u00e3o for m\u00faltiplo de 3 nem 5 ; \"apenas por tr\u00eas\" se i for m\u00faltiplo de 3 mas n\u00e3o de 5 ; \"apenas por cinco\" se i for m\u00faltiplo de 5 mas n\u00e3o de 3 ; \"por tr\u00eas e por cinco\" se i for m\u00faltiplo de 3 e 5 . Escreva duas vers\u00f5es: uma usando while s e outra usando for s. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e imprime uma \"arvorezinha\" conforme a regra abaixo. n = 1 | n = 2 | /|\\ n = 3 | /|\\ //|\\\\ e assim em diante para n = 4, 5, 6... .","title":"Lab 2 - Praticando"},{"location":"Lab2/#lab-2-praticando","text":"Agora que praticamos um pouco no papel (de novo, habilidade fundamental para qualquer programador), vamos voltar ao computador, mas em um ambiente mais geral que o Atmel. Na verdade, o verdadeiro ambiente ser\u00e1 apresentado na leitura que passaremos para ter\u00e7a e na primeira aula de quarta, mas por enquanto vamos usar um mais simples, que n\u00e3o exige instala\u00e7\u00e3o. Entre no site https://www.onlinegdb.com/online_c_compiler . Como mencionado, esse ambiente \u00e9 muito simples: vamos apenas digitar o c\u00f3digo e rod\u00e1-lo atrav\u00e9s do bot\u00e3o verde \"Run\". Se o site estiver lento, tente esse outro: https://repl.it/ Warning Nesse exerc\u00edcio n\u00e3o \u00e9 necess\u00e1rio esperar a valida\u00e7\u00e3o de um professor. Vamos come\u00e7ar analisando o c\u00f3digo que j\u00e1 vem pronto no ambiente. #include <stdio.h> int main () { printf ( \"Hello World\" ); return 0 ; } Novamente, temos um c\u00f3digo curto mas com v\u00e1rios conceitos importantes: a fun\u00e7\u00e3o main equivale ao m\u00e9todo main em Java, ou seja, \u00e9 a fun\u00e7\u00e3o principal , chamada quando o programa \u00e9 rodado; diferente de Java, no entanto, essa fun\u00e7\u00e3o \u00e9 int em vez de void , pois devolve um c\u00f3digo que indica se o programa foi bem-sucedido ou n\u00e3o; por enquanto, consideraremos apenas a devolu\u00e7\u00e3o do c\u00f3digo 0 , que indica que o programa foi, sim, bem-sucedido; #include equivale ao import em Python e Java, ou seja, amplia o conjunto de funcionalidades que o programa pode usar; de fato, \u00e9 justamente por causa do #include <stdio.h> que o programa pode usar a fun\u00e7\u00e3o printf . printf corresponde \u00e0 System.out.print em Java, ou seja, \u00e9 a fun\u00e7\u00e3o respons\u00e1vel por imprimir texto no terminal. No entanto, existe uma diferen\u00e7a de uso entre a printf do C e a System.out.print do Java. O c\u00f3digo abaixo n\u00e3o vai funcionar. #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: \" + n + \", \" + m + \" \\n \" ); return 0 ; } A fun\u00e7\u00e3o printf usa um sistema de interpola\u00e7\u00e3o para exibir valores: #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: %d, %d \\n \" , n , m ); return 0 ; } O c\u00f3digo acima significa \"substitua as duas ocorr\u00eancias de %d pelos valores de n e m , pela ordem\". Parece complicado, mas note que na verdade \u00e9 uma sintaxe mais limpa que a do Java, sem a necessidade de ficar somando strings. O s\u00edmbolo a ser substitu\u00eddo \u00e9 sempre % seguido de letras que representam o tipo do valor. A letra d (de \"decimal\") representa int , enquanto as letras lf (de \"long float\") representam double . #include <stdio.h> int main () { double n = 1.2 ; double m = 2.1 ; printf ( \"Hello World: %lf, %lf\" , n , m ); return 0 ; } Antes de apresentar outros conceitos, vamos praticar um pouco no ambiente. Example int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a soma de 1 a 10 . Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado com printf() Example int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a metade da soma dos n\u00famereos de 1 a 10 Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado Vamos agora finalmente escrever um programa com intera\u00e7\u00e3o de usu\u00e1rio! #include <stdio.h> int main () { int n ; printf ( \"Digite um n\u00famero: \" ); scanf ( \"%d\" , & n ); printf ( \"O n\u00famero digitado \u00e9: %d \\n \" , n ); return 0 ; } Enquanto a fun\u00e7\u00e3o printf usa o s\u00edmbolo %d para indicar que quer \"escrever um inteiro\", a fun\u00e7\u00e3o scanf usa o s\u00edmbolo %d para indicar que quer \"ler um inteiro\". Note tamb\u00e9m uma diferen\u00e7a important\u00edssima entre printf e scanf : apenas no segundo h\u00e1 um & antes da vari\u00e1vel. Os detalhes t\u00e9cnicos disso ser\u00e3o revelados na segunda aula de quarta, mas por enquanto mantenha em mente que se voc\u00ea esquecer o & , o scanf n\u00e3o vai funcionar . Preparados para um exemplo mais avan\u00e7ado? O pr\u00f3ximo mostra de uma s\u00f3 vez: inclus\u00e3o de outra biblioteca al\u00e9m de stdio.h ; defini\u00e7\u00e3o de uma constante; implementa\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o pr\u00f3pria. #include <stdio.h> #include <math.h> #define PI 3.141592 void print_trigo ( int a ) { printf ( \"seno: %lf, cosseno: %lf \\n \" , sin ( a ), cos ( a )); } int main () { int angle ; printf ( \"Digite um \u00e2ngulo em graus: \" ); scanf ( \"%d\" , & angle ); print_trigo ( angle ); return 0 ; } Vejamos o que h\u00e1 de novo no c\u00f3digo: adicionamos #include <math.h> e, por causa disso, pudemos usar as fun\u00e7\u00f5es trigonom\u00e9tricas sin e cos para calcular seno e cosseno respectivamente; definimos a constante PI como sendo o real 3.141592 ; implementamos e chamamos a fun\u00e7\u00e3o print_trigo , que n\u00e3o precisa de return por ser do tipo void ; A diferen\u00e7a entre vari\u00e1veis e constantes \u00e9 que, enquanto uma vari\u00e1vel \u00e9... er... vari\u00e1vel, uma constante \u00e9... er... constante, ou seja, n\u00e3o pode ser alterada: o c\u00f3digo PI = 5 causaria um erro. Por falar em PI , reparou que definimos a constante mas nunca a usamos? Na verdade, n\u00e3o foi um acidente... Question Qual \u00e9 o problema no c\u00f3digo acima? A dica j\u00e1 est\u00e1 dada: para ser resolvido, precisamos usar PI ... Example Resolva o problema! N\u00e3o continue antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre.","title":"Lab 2 - Praticando"},{"location":"Lab2/#exercicios-avancados","text":"Mesmo que n\u00e3o d\u00ea tempo de fazer esses exerc\u00edcios em sala, \u00e9 muito importante que voc\u00ea os fa\u00e7a at\u00e9 quarta para desenferrujar programa\u00e7\u00e3o e praticar C. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro e devolve o m\u00f3dulo desse inteiro. Example Escreva uma fun\u00e7\u00e3o que recebe quatro inteiros, representando as coordenadas de dois pontos no plano cartesiano, e devolve a dist\u00e2ncia de Manhattan (pesquise) entre esses pontos. Voc\u00eas j\u00e1 fiazeram esse exerc\u00edcio em Desenvolvimento Colaborativo \u00c1gil . Assim como o for padr\u00e3o do Java, o for do C n\u00e3o funciona como o for do Python. Na verdade, \u00e9 apenas um \"a\u00e7\u00facar sint\u00e1tico\" que facilita a escrita de loops: for ( i = 0 ; i < 10 ; i ++ ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } equivale a i = 0 ; while ( i < 10 ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... i ++ ; } Em Java existe o enhanced for , que \u00e9 mais parecido com o for do Python, mas n\u00e3o existe uma equival\u00eancia disso em C. Bem-vindos ao baixo n\u00edvel! N\u00e3o temos bolo, mas temos os ingredientes para voc\u00ea fazer um bolo. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e, para cada inteiro i entre 1 e n , imprime uma string conforme a seguinte regra: \"nenhum\" se i n\u00e3o for m\u00faltiplo de 3 nem 5 ; \"apenas por tr\u00eas\" se i for m\u00faltiplo de 3 mas n\u00e3o de 5 ; \"apenas por cinco\" se i for m\u00faltiplo de 5 mas n\u00e3o de 3 ; \"por tr\u00eas e por cinco\" se i for m\u00faltiplo de 3 e 5 . Escreva duas vers\u00f5es: uma usando while s e outra usando for s. Example Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e imprime uma \"arvorezinha\" conforme a regra abaixo. n = 1 | n = 2 | /|\\ n = 3 | /|\\ //|\\\\ e assim em diante para n = 4, 5, 6... .","title":"Exerc\u00edcios Avan\u00e7ados"},{"location":"Lab3/","text":"Lab 3 - Compila\u00e7\u00e3o usando GCC \u00b6 Ontem fizemos atividades usando um compilador online. Apesar de ser pr\u00e1tico, o ambiente online \u00e9 muito limitado e n\u00e3o \u00e9 adequado para as atividades do 5 semestre. Esta leitura visa familiariz\u00e1-lo com as ferramentas de compila\u00e7\u00e3o de c\u00f3digo em C usando o compilador gcc . O ambiente recomendado para a atividade \u00e9 o Ubuntu 18.04 LTS . Outras configura\u00e7\u00f5es s\u00e3o poss\u00edveis, mas n\u00e3o daremos suporte a elas. Tip Memorizar os comandos usados \u00e9 muito mais f\u00e1cil de voc\u00ea digit\u00e1-los no terminal ao inv\u00e9s de copiar e colar. Instala\u00e7\u00e3o local das ferramentas dos cursos \u00b6 As ferramentas que precisamos para o mutir\u00e3o est\u00e3o dispon\u00edveis nos pacotes build-essential e gdb . Os pacotes valgrind e kcachegrind ser\u00e3o usados mais para a frente e j\u00e1 podem ser instalados tamb\u00e9m. $ sudo apt install build-essential gdb valgrind kcachegrind Verifique que tudo funcionou rodando o seguinte comando $ gcc --version Se voc\u00ea recebeu uma mensagem indicando que est\u00e1 usando a vers\u00e3o 7.4 ent\u00e3o tudo est\u00e1 funcionando corretamente. gcc-7 (Ubuntu 7.4.0-29ubuntu1) 7.3.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE Warning Esta padroniza\u00e7\u00e3o \u00e9 importante para evitar dores de cabe\u00e7a com comportamentos espec\u00edficos de uma certa vers\u00e3o. Assim como o restante do ambiente, \u00e9 poss\u00edvel que tudo funcine igual com outras vers\u00f5es do gcc . Por\u00e9m, n\u00e3o daremos suporte a ambientes diferentes do padronizado neste lab. Praticamente qualquer editor de texto ou IDE suporta coloriza\u00e7\u00e3o para C , por\u00e9m recomendamos utilizar alguma ferramenta que tamb\u00e9m corrija erros de sintaxe. Editores como Visual Studio Code (com plugin para C/C++ e Make) e Eclipse CDT s\u00e3o boas escolhas por serem multi-plataforma e suficientemente completos. Eles tamb\u00e9m ajudar\u00e3o muito no come\u00e7o por indicarem erros simples de sintaxe como esquecer de um ; ou usar scanf sem o & . Ap\u00f3s o mutir\u00e3o as atividades de Computa\u00e7\u00e3o Embarcada ser\u00e3o feitas em Windows usando Atmel Studio. Desafios de programa\u00e7\u00e3o e Sistemas de Hardware e Software continuar\u00e3o usando Ubuntu Linux. O qu\u00ea \u00e9 \"compilar\" um c\u00f3digo \u00b6 Diferente de Python, em que podemos rodar diretamente o script, ou Java, em que criamos um arquivo bin\u00e1rio multi-plataforma, programas em C precisam ser convertidos em instru\u00e7\u00f5es nativas do processador para serem executados. Chamamos esse processo que transforma c\u00f3digo em instru\u00e7\u00f5es execut\u00e1veis por uma CPU (f\u00edsica ou virtual) de compila\u00e7\u00e3o . O resultado final da compila\u00e7\u00e3o de um programa em C \u00e9 um arquivo execut\u00e1vel espec\u00edfico para uma arquitetura de CPU e Sistema Operacional. Veremos mais detalhes de como essa transforma\u00e7\u00e3o para c\u00f3digo de m\u00e1quina ocorre em Sistemas Hardware-Software. Compila\u00e7\u00e3o (simples) via linha de comando \u00b6 Usamos o comando gcc para compilar programas em C . Para diminuir a quantidade de erros nos programas podemos passar como argumento algumas flags para exibir erros comuns e para fazer somente otimiza\u00e7\u00f5es que n\u00e3o atrapalhem debug ( -Og ). $ gcc -Wall -pedantic -std = gnu99 -Og -o executavel arquivo.c -Wall : habilita todos avisos do compilador. Este modo indica poss\u00edveis erros cometidos no programa. -pedantic : modo de compila\u00e7\u00e3o mais estrito e mostra ainda mais avisos -std=gnu99 : vers\u00e3o da linguagem C usada ( C99 ) mais extens\u00f5es para sistemas POSIX GNU (veremos o qu\u00ea isto significa mais para frente). -Og : somente aplicar otimiza\u00e7\u00f5es que n\u00e3o atrapalham debuging . -o : output -- nome do execut\u00e1vel gerado Usando este comando podemos compilar um programa definido em um \u00fanico arquivo .c . Example Compile o arquivo printf.c usando o gcc e nomeie o execut\u00e1vel exemplo0 . Rode ele e verifique que tudo continua funcionando. Example Crie um programa que l\u00ea dois inteiros do terminal e determina se o primeiro \u00e9 m\u00faltiplo do segundo. Se o segundo n\u00famero passado for 0 seu programa dever\u00e1 mostrar uma mensagem de erro. Example Adapte seu programa acima para que ele receba v\u00e1rios pares de n\u00fameros e s\u00f3 pare de ser executado quando receber o par \"0 0\". Facilitando o uso da entrada e sa\u00edda padr\u00e3o \u00b6 Para interagir com nossos programas precisamos digitar valores e strings no terminal. Isto se torna chato e repetitivo bem r\u00e1pido. Para facilitar podemos utilizar o recurso de redirecionamento de entrada do terminal. Veja o exemplo abaixo. $ ./prog < arquivo_entrada.txt O programa prog ser\u00e1 executado como se o conte\u00fado do arquivo arquivo_entrada.txt tivesse sido digitado no terminal. Assim, podemos testar facilmente programas como o criado na Tarefa 3 acima sem precisar digitar sempre a mesma entrada. Example Crie um arquivo de entrada para o programa da tarefa 3 e verifique que o resultado do programa \u00e9 o mesmo que quando voc\u00ea digita manualmente os valores no terminal. Example O mesmo vale para a sa\u00edda, mas usando o caractere > . Capture a sa\u00edda do programa da tarefa 3 para um arquivo de nome saida3.txt . Example Podemos combinar o redirecionamento de entrada e sa\u00edda no mesmo comando. Teste esta funcionalidade usando o programa da tarefa 3.","title":"Lab 3 - Compila\u00e7\u00e3o usando GCC"},{"location":"Lab3/#lab-3-compilacao-usando-gcc","text":"Ontem fizemos atividades usando um compilador online. Apesar de ser pr\u00e1tico, o ambiente online \u00e9 muito limitado e n\u00e3o \u00e9 adequado para as atividades do 5 semestre. Esta leitura visa familiariz\u00e1-lo com as ferramentas de compila\u00e7\u00e3o de c\u00f3digo em C usando o compilador gcc . O ambiente recomendado para a atividade \u00e9 o Ubuntu 18.04 LTS . Outras configura\u00e7\u00f5es s\u00e3o poss\u00edveis, mas n\u00e3o daremos suporte a elas. Tip Memorizar os comandos usados \u00e9 muito mais f\u00e1cil de voc\u00ea digit\u00e1-los no terminal ao inv\u00e9s de copiar e colar.","title":"Lab 3 - Compila\u00e7\u00e3o usando GCC"},{"location":"Lab3/#instalacao-local-das-ferramentas-dos-cursos","text":"As ferramentas que precisamos para o mutir\u00e3o est\u00e3o dispon\u00edveis nos pacotes build-essential e gdb . Os pacotes valgrind e kcachegrind ser\u00e3o usados mais para a frente e j\u00e1 podem ser instalados tamb\u00e9m. $ sudo apt install build-essential gdb valgrind kcachegrind Verifique que tudo funcionou rodando o seguinte comando $ gcc --version Se voc\u00ea recebeu uma mensagem indicando que est\u00e1 usando a vers\u00e3o 7.4 ent\u00e3o tudo est\u00e1 funcionando corretamente. gcc-7 (Ubuntu 7.4.0-29ubuntu1) 7.3.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE Warning Esta padroniza\u00e7\u00e3o \u00e9 importante para evitar dores de cabe\u00e7a com comportamentos espec\u00edficos de uma certa vers\u00e3o. Assim como o restante do ambiente, \u00e9 poss\u00edvel que tudo funcine igual com outras vers\u00f5es do gcc . Por\u00e9m, n\u00e3o daremos suporte a ambientes diferentes do padronizado neste lab. Praticamente qualquer editor de texto ou IDE suporta coloriza\u00e7\u00e3o para C , por\u00e9m recomendamos utilizar alguma ferramenta que tamb\u00e9m corrija erros de sintaxe. Editores como Visual Studio Code (com plugin para C/C++ e Make) e Eclipse CDT s\u00e3o boas escolhas por serem multi-plataforma e suficientemente completos. Eles tamb\u00e9m ajudar\u00e3o muito no come\u00e7o por indicarem erros simples de sintaxe como esquecer de um ; ou usar scanf sem o & . Ap\u00f3s o mutir\u00e3o as atividades de Computa\u00e7\u00e3o Embarcada ser\u00e3o feitas em Windows usando Atmel Studio. Desafios de programa\u00e7\u00e3o e Sistemas de Hardware e Software continuar\u00e3o usando Ubuntu Linux.","title":"Instala\u00e7\u00e3o local das ferramentas dos cursos"},{"location":"Lab3/#o-que-e-compilar-um-codigo","text":"Diferente de Python, em que podemos rodar diretamente o script, ou Java, em que criamos um arquivo bin\u00e1rio multi-plataforma, programas em C precisam ser convertidos em instru\u00e7\u00f5es nativas do processador para serem executados. Chamamos esse processo que transforma c\u00f3digo em instru\u00e7\u00f5es execut\u00e1veis por uma CPU (f\u00edsica ou virtual) de compila\u00e7\u00e3o . O resultado final da compila\u00e7\u00e3o de um programa em C \u00e9 um arquivo execut\u00e1vel espec\u00edfico para uma arquitetura de CPU e Sistema Operacional. Veremos mais detalhes de como essa transforma\u00e7\u00e3o para c\u00f3digo de m\u00e1quina ocorre em Sistemas Hardware-Software.","title":"O qu\u00ea \u00e9 \"compilar\" um c\u00f3digo"},{"location":"Lab3/#compilacao-simples-via-linha-de-comando","text":"Usamos o comando gcc para compilar programas em C . Para diminuir a quantidade de erros nos programas podemos passar como argumento algumas flags para exibir erros comuns e para fazer somente otimiza\u00e7\u00f5es que n\u00e3o atrapalhem debug ( -Og ). $ gcc -Wall -pedantic -std = gnu99 -Og -o executavel arquivo.c -Wall : habilita todos avisos do compilador. Este modo indica poss\u00edveis erros cometidos no programa. -pedantic : modo de compila\u00e7\u00e3o mais estrito e mostra ainda mais avisos -std=gnu99 : vers\u00e3o da linguagem C usada ( C99 ) mais extens\u00f5es para sistemas POSIX GNU (veremos o qu\u00ea isto significa mais para frente). -Og : somente aplicar otimiza\u00e7\u00f5es que n\u00e3o atrapalham debuging . -o : output -- nome do execut\u00e1vel gerado Usando este comando podemos compilar um programa definido em um \u00fanico arquivo .c . Example Compile o arquivo printf.c usando o gcc e nomeie o execut\u00e1vel exemplo0 . Rode ele e verifique que tudo continua funcionando. Example Crie um programa que l\u00ea dois inteiros do terminal e determina se o primeiro \u00e9 m\u00faltiplo do segundo. Se o segundo n\u00famero passado for 0 seu programa dever\u00e1 mostrar uma mensagem de erro. Example Adapte seu programa acima para que ele receba v\u00e1rios pares de n\u00fameros e s\u00f3 pare de ser executado quando receber o par \"0 0\".","title":"Compila\u00e7\u00e3o (simples) via linha de comando"},{"location":"Lab3/#facilitando-o-uso-da-entrada-e-saida-padrao","text":"Para interagir com nossos programas precisamos digitar valores e strings no terminal. Isto se torna chato e repetitivo bem r\u00e1pido. Para facilitar podemos utilizar o recurso de redirecionamento de entrada do terminal. Veja o exemplo abaixo. $ ./prog < arquivo_entrada.txt O programa prog ser\u00e1 executado como se o conte\u00fado do arquivo arquivo_entrada.txt tivesse sido digitado no terminal. Assim, podemos testar facilmente programas como o criado na Tarefa 3 acima sem precisar digitar sempre a mesma entrada. Example Crie um arquivo de entrada para o programa da tarefa 3 e verifique que o resultado do programa \u00e9 o mesmo que quando voc\u00ea digita manualmente os valores no terminal. Example O mesmo vale para a sa\u00edda, mas usando o caractere > . Capture a sa\u00edda do programa da tarefa 3 para um arquivo de nome saida3.txt . Example Podemos combinar o redirecionamento de entrada e sa\u00edda no mesmo comando. Teste esta funcionalidade usando o programa da tarefa 3.","title":"Facilitando o uso da entrada e sa\u00edda padr\u00e3o"},{"location":"Lab4/","text":"Lab 4 - Arrays, Strings e Matrizes \u00b6 Na \u00faltima aula trabalhamos com conceitos b\u00e1sicos de C e com tipos de dados simples (inteiros e n\u00fameros fracion\u00e1rios). Hoje veremos as primeiras estruturas complexas em C : vetores, matrizes e strings. Arrays em C \u00b6 Criamos arrays de tamanho fixo em C usando a seguinte sintaxe: long A [ 100 ]; Basta adicionar [] ap\u00f3s o tipo e teremos um array de tamanho constante (i.e. n\u00e3o dependente da entrada do usu\u00e1rio). N\u00e3o \u00e9 poss\u00edvel redimensionar o array . Depois de declarado ele ter\u00e1 para sempre o mesmo tamanho. O acesso a elementos tamb\u00e9m \u00e9 bastante simples: printf ( \"%ld \\n \" , A [ 3 ]); A linha acima imprime o primeira valor do vetor. O uso com scanf segue a mesma l\u00f3gica dos tipos simples: scanf ( \"%ld\" , & vetor [ 0 ]); Question Simule o c\u00f3digo abaixo manualmente e escreva sua sa\u00edda abaixo. #include <stdio.h> int main ( int argc , char * argv []) { long vetor [ 5 ]; int i ; for ( i = 0 ; i <= 5 ; i ++ ) { if ( vetor [ i ] % 2 == 0 ) { printf ( \"Par! \" ); } printf ( \"i: %d, vetor[i]: %ld \\n \" , i , vetor [ i ]); } return 0 ; } Question O c\u00f3digo acima est\u00e1 no arquivo /Lab4/erro_comum1.c . Compile e execute ele. Os resultados foram os esperados? Se n\u00e3o, voc\u00ea consegue explicar por que eles foram diferentes? Resposta Como podemos ver, o c\u00f3digo compila, mas seu comportamento \u00e9 indefinido por duas raz\u00f5es: O vetor n\u00e3o \u00e9 inicializado com 0 quando \u00e9 criado. A posi\u00e7\u00e3o vetor[5] n\u00e3o \u00e9 v\u00e1lida e pode resultar na leitura de dados inv\u00e1lidos da mem\u00f3ria. Tip Diferentemente de outras linguagens, C n\u00e3o verifica os \u00edndices automaticamente nem inicializa o elementos do vetor com 0. Al\u00e9m disto, n\u00e3o \u00e9 poss\u00edvel obter o tamanho de um vetor a partir de seu nome. Um ponto importante \u00e9 que o sistema de tipos n\u00e3o permite a convers\u00e3o/passagem de vetores do mesmo tipo, mas com tamanhos diferentes. Assim, a fun\u00e7\u00e3o abaixo n\u00e3o aceitaria como argumento a vari\u00e1vel double arr[4] , pois s\u00f3 aceita vetores de tamanho 3. double soma ( double arr [ 3 ]) { double s = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { s += arr [ i ]; } return s ; } Para faz\u00ea-la aceitar vetores de tamanho qualquer poder\u00edamos mudar sua assinatura para n\u00e3o checar o tamanho do vetor e pass\u00e1-lo como argumento da fun\u00e7\u00e3o. double soma ( double arr [], int n ); Example Trabalharemos com o arquivo Lab4/soma.c . Abra-o e implemente, no local indicado, a fun\u00e7\u00e3o soma com a assinatura acima. Lembre-se que em C arrays n\u00e3o conhecem seu tamanho, ent\u00e3o \u00e9 de sua responsabilidade acessar somente elementos v\u00e1lidos e checar se o vetor n\u00e3o est\u00e1 vazio (ou seja, n < 1 ) Question O arquivo usado acima cont\u00e9m v\u00e1rios testes na fun\u00e7\u00e3o main . Leia a fun\u00e7\u00e3o main e escreva abaixo a nota\u00e7\u00e3o usada para inicializar um array com valores constantes. Como voc\u00ea inicializaria um vetor de int com os valores 0, 2, 3, 2, 5 0, 2, 3, 2, 5 ? Strings \u00b6 Como visto na expositiva, strings s\u00e3o arrays de caracteres sendo que o \u00faltimo elemento da string cont\u00e9m um caractere '\\0' . Logo, uma string declarada como char str[100] pode guardar strings de at\u00e9 99 caracteres (mais 1 para o '\\0' ). Se a string tiver comprimento menor o restante das posi\u00e7\u00f5es simplesmente n\u00e3o \u00e9 utilizado. Note Em C podemos usar: \\0 , NULL , e 0 para representar a mesma coisa! Tip Uma string em C nada mais \u00e9 do que um array do tipo char cujo \u00faltimo elemento \u00e9 um \\0 . As duas linhas abaixo tem o mesmo efeito. char arr [] = \"insper\" ; char arr2 [] = { 'i' , 'n' , 's' , 'p' , 'e' , 'r' , '\\0' }; Claramente a primeira \u00e9 muito mais conveniente ;) Question Em C , qual a diferen\u00e7a entre \"a\" e 'a' ? Para imprimir uma string no terminal basta usar o c\u00f3digo %s na string de formata\u00e7\u00e3o do printf: char str [ 10 ] = \"world!\" ; printf ( \"hello %s \\n \" , str ); J\u00e1 a leitura de strings \u00e9 feita usando a fun\u00e7\u00e3o fgets , que recebe um array de char com tamanho n e l\u00ea at\u00e9 n-1 caracteres de um arquivo ou do terminal. fgets para quando encher o vetor ou quando encontrar uma quebra de linha \\n . No exemplo abaixo, stdin ( Standard Input ) representa o terminal. #define STRING_LEN 10 // Tamanho da string 0..9 char str [ STRING_LEN ]; fgets ( str , STRING_LEN , stdin ); // precisamos passar o tamanho m\u00e1ximo // + 1 da nossa string. Question Para iterar sobre todos os caracteres de uma string precisamos saber seu tamanho? Como podemos fazer isto? Dica : reveja a imagem e o exemplo de c\u00f3digo do come\u00e7o da se\u00e7\u00e3o. Example Crie um programa, do zero, que declara uma string de tamanho m\u00e1ximo 100 leia uma linha do terminal conte o n\u00famero de vezes que a letra \"a\" aparece mostre esse valor no terminal Example Modifique o programa acima para contar tamb\u00e9m o n\u00famero de vezes que o caractere \"1\" aparece na string recebida. Matrizes \u00b6 Como visto na expositiva, matrizes em C nada mais s\u00e3o que vetores colocados um ap\u00f3s o outro. long mat [ 10 ][ 3 ]; printf ( \"%d\" , mat [ 0 ][ 2 ]); /* acessa linha 0, coluna 3 */ scanf ( \"%d\" , & mat [ 1 ][ 1 ]); // armazena inteiro digitado na posi\u00e7\u00e3o 1,5 Perceba que toda a primeira linha \u00e9 armazenada (contendo 3 long s) antes do in\u00edcio da segunda linha. Ou seja, a matriz \u00e9 armazenada \"deitada\" na mem\u00f3ria, uma linha ap\u00f3s a outra. Question Levando em conta que a matriz \u00e9 guardada como na figura acima, em qual posi\u00e7\u00e3o da mem\u00f3ria est\u00e3o armazenados os seguintes elementos? Voc\u00ea deve contar a partir do primeiro elemento ( mat[0][0] ). mat[0][2] mat[1][2] mat[2][0] Example Fa\u00e7a, do zero, um programa que l\u00ea uma matriz 5\\times 4 5\\times 4 e imprime no terminal a soma de cada uma de suas colunas. Example Modifique seu programa acima para, al\u00e9m das somas de cada coluna, imprimir tamb\u00e9m o \u00edndice da coluna de maior valor. Exerc\u00edcios \u00b6 Agora que j\u00e1 trabalhamos um pouco com arrays , strings e matrizes est\u00e1 na hora de praticar com exerc\u00edcios mais complexos. Estes exerc\u00edcios n\u00e3o s\u00e3o opcionais, sua realiza\u00e7\u00e3o \u00e9 essencial para cumprir os objetivos do Mutir\u00e3o. Arrays \u00b6 Example Escreva, do zero, um programa que Leia um inteiro n do terminal (n\u00famero de elementos do vetor) Leia n n\u00fameros fracion\u00e1rios e guard\u00e1-los em um array. Chame uma fun\u00e7\u00e3o para calcular a m\u00e9dia do vetor. Imprima a m\u00e9dia calculada. Seu programa dever\u00e1 calcular a m\u00e9dia usando uma fun\u00e7\u00e3o avg escrita por voc\u00ea mesmo e pode supor que n < 100 . Para facilitar seus testes, escreva dois arquivos de entrada e use < para rodar o programa. Example Modifique seu programa acima para que ele imprima tamb\u00e9m a vari\u00e2ncia do vetor. Strings \u00b6 Question Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorna 1 se ela \u00e9 um pal\u00edndromo ou 0 caso contr\u00e1rio. Question Um aluno fez a seguinte fun\u00e7\u00e3o para c\u00f3pia de strings. void copia_string ( char str1 [], char str2 []) { int i = 0 ; while ( str1 [ i ] != '\\0' ) { str2 [ i ] = str1 [ i ]; i ++ ; } } Existem pelo menos dois problemas graves neste c\u00f3digo. Voc\u00ea consegue identific\u00e1-los? Example Fa\u00e7a, do zero, um programa que leia uma string (tamanho m\u00e1ximo 200) e crie uma nova string trocando toda letra por mai\u00fasculas. Seu programa dever\u00e1 imprimir a string original e sua vers\u00e3o em mai\u00fasculas. Seu programa deve funcionar para strings contendo n\u00fameros, s\u00edmbolos, espa\u00e7os e letras mai\u00fasculas e min\u00fasculas. Consulte a tabela abaixo, se necess\u00e1rio. Matrizes \u00b6 O formato de imagens mais simples existente \u00e9 o pgm , que reprenta uma imagem em n\u00edveis de cinza como uma matriz com valores entre 0 (para preto) e 255 (para branco). Seu formato \u00e9 o seguinte. P2 W H 255 ......... Ou seja, primeiro lemos uma linha com a string \"P2\", depois dois inteiros w e h representando a largura e a altura da imagem, depois o valor 255. Ent\u00e3o lemos w * h valores representando os pixels da imagem. Disponibilizamos v\u00e1rias imagens de exemplo na pasta /Lab4/exemplos . Voc\u00eas podem abr\u00ed-las com qualquer editor de texto para ver seu conte\u00fado. Warning Nas tarefas abaixo estamos supondo que voc\u00ea usa < para passar o conte\u00fado das imagens exemplo para seu programa no terminal e > para salvar o resultado do terminal em uma nova imagem pgm . Para as tarefas abaixo voc\u00ea pode supor que as imagens tem tamanho m\u00e1ximo 512\\times 512 512\\times 512 . Para deixar seu c\u00f3digo mais limpo, defina duas constantes MAXW e MAXH para guardar estes valores. Example Crie, do zero, um programa que l\u00ea o cabe\u00e7alho de uma imagem pgm (primeiras tr\u00eas linhas) passada no terminal e imprima as dimens\u00f5es da imagem. N\u00e3o se esque\u00e7a de ler tamb\u00e9m o n\u00famero 255 na terceira linha. Example Crie uma fun\u00e7\u00e3o void le_imagem(int mat[MAXH][MAXW], int w, int h) que l\u00ea os valores da matriz da imagem e os escreve em mat . Example Crie uma fun\u00e7\u00e3o void escreve_imagem(int max[MAXH][MAXW], int w, int h) que escreve o cabe\u00e7alho e todos os pixels de uma imagem no terminal seguindo o formato pgm descrito acima. Example Verifique que seu programa est\u00e1 correto fazendo uma fun\u00e7\u00e3o main que simplesmente l\u00ea uma imagem e logo em seguida a escreve no terminal. Verifique visualmente que a imagem de sa\u00edda \u00e9 igual a original. Example Finalmente, crie uma fun\u00e7\u00e3o void limiar(int max[MAXH][MAXW], int w, int h, int lim) que aplica um limiar de 127 na imagem e chame-a na sua fun\u00e7\u00e3o main . Verifique visualmente que a imagem de sa\u00edda \u00e9 a esperada.","title":"Lab 4 - Arrays, Strings e Matrizes"},{"location":"Lab4/#lab-4-arrays-strings-e-matrizes","text":"Na \u00faltima aula trabalhamos com conceitos b\u00e1sicos de C e com tipos de dados simples (inteiros e n\u00fameros fracion\u00e1rios). Hoje veremos as primeiras estruturas complexas em C : vetores, matrizes e strings.","title":"Lab 4 - Arrays, Strings e Matrizes"},{"location":"Lab4/#arrays-em-c","text":"Criamos arrays de tamanho fixo em C usando a seguinte sintaxe: long A [ 100 ]; Basta adicionar [] ap\u00f3s o tipo e teremos um array de tamanho constante (i.e. n\u00e3o dependente da entrada do usu\u00e1rio). N\u00e3o \u00e9 poss\u00edvel redimensionar o array . Depois de declarado ele ter\u00e1 para sempre o mesmo tamanho. O acesso a elementos tamb\u00e9m \u00e9 bastante simples: printf ( \"%ld \\n \" , A [ 3 ]); A linha acima imprime o primeira valor do vetor. O uso com scanf segue a mesma l\u00f3gica dos tipos simples: scanf ( \"%ld\" , & vetor [ 0 ]); Question Simule o c\u00f3digo abaixo manualmente e escreva sua sa\u00edda abaixo. #include <stdio.h> int main ( int argc , char * argv []) { long vetor [ 5 ]; int i ; for ( i = 0 ; i <= 5 ; i ++ ) { if ( vetor [ i ] % 2 == 0 ) { printf ( \"Par! \" ); } printf ( \"i: %d, vetor[i]: %ld \\n \" , i , vetor [ i ]); } return 0 ; } Question O c\u00f3digo acima est\u00e1 no arquivo /Lab4/erro_comum1.c . Compile e execute ele. Os resultados foram os esperados? Se n\u00e3o, voc\u00ea consegue explicar por que eles foram diferentes? Resposta Como podemos ver, o c\u00f3digo compila, mas seu comportamento \u00e9 indefinido por duas raz\u00f5es: O vetor n\u00e3o \u00e9 inicializado com 0 quando \u00e9 criado. A posi\u00e7\u00e3o vetor[5] n\u00e3o \u00e9 v\u00e1lida e pode resultar na leitura de dados inv\u00e1lidos da mem\u00f3ria. Tip Diferentemente de outras linguagens, C n\u00e3o verifica os \u00edndices automaticamente nem inicializa o elementos do vetor com 0. Al\u00e9m disto, n\u00e3o \u00e9 poss\u00edvel obter o tamanho de um vetor a partir de seu nome. Um ponto importante \u00e9 que o sistema de tipos n\u00e3o permite a convers\u00e3o/passagem de vetores do mesmo tipo, mas com tamanhos diferentes. Assim, a fun\u00e7\u00e3o abaixo n\u00e3o aceitaria como argumento a vari\u00e1vel double arr[4] , pois s\u00f3 aceita vetores de tamanho 3. double soma ( double arr [ 3 ]) { double s = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { s += arr [ i ]; } return s ; } Para faz\u00ea-la aceitar vetores de tamanho qualquer poder\u00edamos mudar sua assinatura para n\u00e3o checar o tamanho do vetor e pass\u00e1-lo como argumento da fun\u00e7\u00e3o. double soma ( double arr [], int n ); Example Trabalharemos com o arquivo Lab4/soma.c . Abra-o e implemente, no local indicado, a fun\u00e7\u00e3o soma com a assinatura acima. Lembre-se que em C arrays n\u00e3o conhecem seu tamanho, ent\u00e3o \u00e9 de sua responsabilidade acessar somente elementos v\u00e1lidos e checar se o vetor n\u00e3o est\u00e1 vazio (ou seja, n < 1 ) Question O arquivo usado acima cont\u00e9m v\u00e1rios testes na fun\u00e7\u00e3o main . Leia a fun\u00e7\u00e3o main e escreva abaixo a nota\u00e7\u00e3o usada para inicializar um array com valores constantes. Como voc\u00ea inicializaria um vetor de int com os valores 0, 2, 3, 2, 5 0, 2, 3, 2, 5 ?","title":"Arrays em C"},{"location":"Lab4/#strings","text":"Como visto na expositiva, strings s\u00e3o arrays de caracteres sendo que o \u00faltimo elemento da string cont\u00e9m um caractere '\\0' . Logo, uma string declarada como char str[100] pode guardar strings de at\u00e9 99 caracteres (mais 1 para o '\\0' ). Se a string tiver comprimento menor o restante das posi\u00e7\u00f5es simplesmente n\u00e3o \u00e9 utilizado. Note Em C podemos usar: \\0 , NULL , e 0 para representar a mesma coisa! Tip Uma string em C nada mais \u00e9 do que um array do tipo char cujo \u00faltimo elemento \u00e9 um \\0 . As duas linhas abaixo tem o mesmo efeito. char arr [] = \"insper\" ; char arr2 [] = { 'i' , 'n' , 's' , 'p' , 'e' , 'r' , '\\0' }; Claramente a primeira \u00e9 muito mais conveniente ;) Question Em C , qual a diferen\u00e7a entre \"a\" e 'a' ? Para imprimir uma string no terminal basta usar o c\u00f3digo %s na string de formata\u00e7\u00e3o do printf: char str [ 10 ] = \"world!\" ; printf ( \"hello %s \\n \" , str ); J\u00e1 a leitura de strings \u00e9 feita usando a fun\u00e7\u00e3o fgets , que recebe um array de char com tamanho n e l\u00ea at\u00e9 n-1 caracteres de um arquivo ou do terminal. fgets para quando encher o vetor ou quando encontrar uma quebra de linha \\n . No exemplo abaixo, stdin ( Standard Input ) representa o terminal. #define STRING_LEN 10 // Tamanho da string 0..9 char str [ STRING_LEN ]; fgets ( str , STRING_LEN , stdin ); // precisamos passar o tamanho m\u00e1ximo // + 1 da nossa string. Question Para iterar sobre todos os caracteres de uma string precisamos saber seu tamanho? Como podemos fazer isto? Dica : reveja a imagem e o exemplo de c\u00f3digo do come\u00e7o da se\u00e7\u00e3o. Example Crie um programa, do zero, que declara uma string de tamanho m\u00e1ximo 100 leia uma linha do terminal conte o n\u00famero de vezes que a letra \"a\" aparece mostre esse valor no terminal Example Modifique o programa acima para contar tamb\u00e9m o n\u00famero de vezes que o caractere \"1\" aparece na string recebida.","title":"Strings"},{"location":"Lab4/#matrizes","text":"Como visto na expositiva, matrizes em C nada mais s\u00e3o que vetores colocados um ap\u00f3s o outro. long mat [ 10 ][ 3 ]; printf ( \"%d\" , mat [ 0 ][ 2 ]); /* acessa linha 0, coluna 3 */ scanf ( \"%d\" , & mat [ 1 ][ 1 ]); // armazena inteiro digitado na posi\u00e7\u00e3o 1,5 Perceba que toda a primeira linha \u00e9 armazenada (contendo 3 long s) antes do in\u00edcio da segunda linha. Ou seja, a matriz \u00e9 armazenada \"deitada\" na mem\u00f3ria, uma linha ap\u00f3s a outra. Question Levando em conta que a matriz \u00e9 guardada como na figura acima, em qual posi\u00e7\u00e3o da mem\u00f3ria est\u00e3o armazenados os seguintes elementos? Voc\u00ea deve contar a partir do primeiro elemento ( mat[0][0] ). mat[0][2] mat[1][2] mat[2][0] Example Fa\u00e7a, do zero, um programa que l\u00ea uma matriz 5\\times 4 5\\times 4 e imprime no terminal a soma de cada uma de suas colunas. Example Modifique seu programa acima para, al\u00e9m das somas de cada coluna, imprimir tamb\u00e9m o \u00edndice da coluna de maior valor.","title":"Matrizes"},{"location":"Lab4/#exercicios","text":"Agora que j\u00e1 trabalhamos um pouco com arrays , strings e matrizes est\u00e1 na hora de praticar com exerc\u00edcios mais complexos. Estes exerc\u00edcios n\u00e3o s\u00e3o opcionais, sua realiza\u00e7\u00e3o \u00e9 essencial para cumprir os objetivos do Mutir\u00e3o.","title":"Exerc\u00edcios"},{"location":"Lab4/#arrays","text":"Example Escreva, do zero, um programa que Leia um inteiro n do terminal (n\u00famero de elementos do vetor) Leia n n\u00fameros fracion\u00e1rios e guard\u00e1-los em um array. Chame uma fun\u00e7\u00e3o para calcular a m\u00e9dia do vetor. Imprima a m\u00e9dia calculada. Seu programa dever\u00e1 calcular a m\u00e9dia usando uma fun\u00e7\u00e3o avg escrita por voc\u00ea mesmo e pode supor que n < 100 . Para facilitar seus testes, escreva dois arquivos de entrada e use < para rodar o programa. Example Modifique seu programa acima para que ele imprima tamb\u00e9m a vari\u00e2ncia do vetor.","title":"Arrays"},{"location":"Lab4/#strings_1","text":"Question Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorna 1 se ela \u00e9 um pal\u00edndromo ou 0 caso contr\u00e1rio. Question Um aluno fez a seguinte fun\u00e7\u00e3o para c\u00f3pia de strings. void copia_string ( char str1 [], char str2 []) { int i = 0 ; while ( str1 [ i ] != '\\0' ) { str2 [ i ] = str1 [ i ]; i ++ ; } } Existem pelo menos dois problemas graves neste c\u00f3digo. Voc\u00ea consegue identific\u00e1-los? Example Fa\u00e7a, do zero, um programa que leia uma string (tamanho m\u00e1ximo 200) e crie uma nova string trocando toda letra por mai\u00fasculas. Seu programa dever\u00e1 imprimir a string original e sua vers\u00e3o em mai\u00fasculas. Seu programa deve funcionar para strings contendo n\u00fameros, s\u00edmbolos, espa\u00e7os e letras mai\u00fasculas e min\u00fasculas. Consulte a tabela abaixo, se necess\u00e1rio.","title":"Strings"},{"location":"Lab4/#matrizes_1","text":"O formato de imagens mais simples existente \u00e9 o pgm , que reprenta uma imagem em n\u00edveis de cinza como uma matriz com valores entre 0 (para preto) e 255 (para branco). Seu formato \u00e9 o seguinte. P2 W H 255 ......... Ou seja, primeiro lemos uma linha com a string \"P2\", depois dois inteiros w e h representando a largura e a altura da imagem, depois o valor 255. Ent\u00e3o lemos w * h valores representando os pixels da imagem. Disponibilizamos v\u00e1rias imagens de exemplo na pasta /Lab4/exemplos . Voc\u00eas podem abr\u00ed-las com qualquer editor de texto para ver seu conte\u00fado. Warning Nas tarefas abaixo estamos supondo que voc\u00ea usa < para passar o conte\u00fado das imagens exemplo para seu programa no terminal e > para salvar o resultado do terminal em uma nova imagem pgm . Para as tarefas abaixo voc\u00ea pode supor que as imagens tem tamanho m\u00e1ximo 512\\times 512 512\\times 512 . Para deixar seu c\u00f3digo mais limpo, defina duas constantes MAXW e MAXH para guardar estes valores. Example Crie, do zero, um programa que l\u00ea o cabe\u00e7alho de uma imagem pgm (primeiras tr\u00eas linhas) passada no terminal e imprima as dimens\u00f5es da imagem. N\u00e3o se esque\u00e7a de ler tamb\u00e9m o n\u00famero 255 na terceira linha. Example Crie uma fun\u00e7\u00e3o void le_imagem(int mat[MAXH][MAXW], int w, int h) que l\u00ea os valores da matriz da imagem e os escreve em mat . Example Crie uma fun\u00e7\u00e3o void escreve_imagem(int max[MAXH][MAXW], int w, int h) que escreve o cabe\u00e7alho e todos os pixels de uma imagem no terminal seguindo o formato pgm descrito acima. Example Verifique que seu programa est\u00e1 correto fazendo uma fun\u00e7\u00e3o main que simplesmente l\u00ea uma imagem e logo em seguida a escreve no terminal. Verifique visualmente que a imagem de sa\u00edda \u00e9 igual a original. Example Finalmente, crie uma fun\u00e7\u00e3o void limiar(int max[MAXH][MAXW], int w, int h, int lim) que aplica um limiar de 127 na imagem e chame-a na sua fun\u00e7\u00e3o main . Verifique visualmente que a imagem de sa\u00edda \u00e9 a esperada.","title":"Matrizes"},{"location":"Lab5/","text":"Lab 5 - Ponteiros e structs \u00b6 Info Por favor, fa\u00e7am esta atividade em dupla e lembrem das regras. Os enunciados de programa\u00e7\u00e3o dizem \"o que\" a fun\u00e7\u00e3o/programa deve fazer, mas n\u00e3o dizem \"como\" deve fazer. N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio de programa\u00e7\u00e3o, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo. Introdu\u00e7\u00e3o \u00b6 Podemos dizer que praticamente todos os conceitos vistos at\u00e9 agora s\u00e3o adapta\u00e7\u00f5es de conceitos vistos anteriormente em Python e Java . Neste guia, finalmente exploramos alguns conceitos \"exclusivos\" de C e outras linguagens de baixo n\u00edvel. Para introduzir o primeiro deles, vamos come\u00e7ar com uma pergunta. Question Considerando o que vimos anteriormente sobre scanf , passagem por valor e passagem por refer\u00eancia , porque a chamada scanf ( \"%d\" , & n ); n\u00e3o funcionaria sem o & ? Pode parecer estranho, mas voc\u00ea n\u00e3o precisa saber a defini\u00e7\u00e3o de & para poder responder! Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores. Endere\u00e7os \u00b6 Como vimos anteriormente, os conjuntos de vari\u00e1veis de duas fun\u00e7\u00f5es diferentes s\u00e3o totalmente separados. Ou seja, no exemplo abaixo, void foo ( int n ) { n ++ ; } int bar () { int n = 0 ; foo ( n ); return n ; } a fun\u00e7\u00e3o bar devolve 0 , pois a vari\u00e1vel n de foo \u00e9 diferente da vari\u00e1vel n de bar , apesar das duas terem o mesmo nome. Cabe enfatizar que \u00e9 bom que esse seja o comportamento padr\u00e3o! Geralmente queremos evitar situa\u00e7\u00f5es nas quais uma fun\u00e7\u00e3o altera vari\u00e1veis de outra fun\u00e7\u00e3o. Essas situa\u00e7\u00f5es s\u00e3o conhecidas como efeitos colaterais e costumam ser indesejadas por tornarem o c\u00f3digo mais imprevis\u00edvel, aumentarem a probabilidade de bugs e dificultarem testes. No entanto, se soubermos muito bem o que estamos fazendo, efeitos colaterais podem ser \u00fateis. O scanf \u00e9 o exemplo \u00f3bvio disso! Ent\u00e3o vamos mostrar como permiti-los. O problema do exemplo anterior \u00e9 que o nome de uma vari\u00e1vel \u00e9 um identificador local , ou seja, vale apenas dentro do escopo da fun\u00e7\u00e3o na qual a vari\u00e1vel foi declarada. Mas a vari\u00e1vel tamb\u00e9m possui um identificador global que \u00e9 seu endere\u00e7o . Se uma fun\u00e7\u00e3o sabe o endere\u00e7o de uma vari\u00e1vel, essa vari\u00e1vel pode ser modificada pela fun\u00e7\u00e3o mesmo se n\u00e3o foi declarada dentro dela. Para entender melhor o conceito de endere\u00e7o, basta pensar na mem\u00f3ria como um \"vetorz\u00e3o\" e na vari\u00e1vel como um elemento desse \"vetorz\u00e3o\". O endere\u00e7o, nessa analogia, seria o \u00edndice desse elemento. E como obtemos o endere\u00e7o de uma vari\u00e1vel? Basta usar o operador un\u00e1rio & . Isso explica o que acontece em rela\u00e7\u00e3o ao scanf : o que a fun\u00e7\u00e3o recebe n\u00e3o \u00e9 o valor de uma vari\u00e1vel, e sim seu endere\u00e7o. Assim, ganha o poder de escrever nela o valor digitado pelo usu\u00e1rio. Ent\u00e3o lembre-se: sempre que encontrar o s\u00edmbolo & , leia como se ele fosse a express\u00e3o \"endere\u00e7o de\" . & a // l\u00ea-se \"endere\u00e7o de a\" & b // l\u00ea-se \"endere\u00e7o de b\" & abobrinha // l\u00ea-se \"endere\u00e7o de abobrinha\" Mas para podermos passar endere\u00e7os para l\u00e1 e para c\u00e1, precisamos de vari\u00e1veis especiais que guardam endere\u00e7os. Essas vari\u00e1veis s\u00e3o conhecidas como apontadores ou ponteiros ( pointers em ingl\u00eas) e indicadas pelo s\u00edmbolo * . Antes de dar mais detalhes, vamos dar uma dica simples e valiosa em rela\u00e7\u00e3o a esse s\u00edmbolo. A Regra de Ouro \u00b6 Dizemos que um apontador p aponta para uma vari\u00e1vel v se o endere\u00e7o de v est\u00e1 armazenado em p . Visualmente, podemos representar isso da seguinte forma: Esta figura \u00e9 uma representa\u00e7\u00e3o visual de p apontar para v . Nesse caso, v \u00e9 uma vari\u00e1vel inteira cujo valor \u00e9 5 e p \u00e9 um apontador cujo valor \u00e9 o endere\u00e7o de v . Acostume-se com essa representa\u00e7\u00e3o visual, ali\u00e1s, pois ela ser\u00e1 muito usada em Desafios de Programa\u00e7\u00e3o ! Mas o que realmente queremos enfatizar aqui \u00e9 que, a partir dessa terminologia, podemos derivar uma pequena regra que ajuda muito a compreender c\u00f3digos que usam * no contexto de endere\u00e7os e apontadores: sempre que encontrar o s\u00edmbolo * , leia como se ele fosse a express\u00e3o \"vari\u00e1vel apontada por\" . Sem contexto essa regra parece estranha, ent\u00e3o vamos aos exemplos! Apontadores \u00b6 Vamos declarar o apontador p do exemplo acima. int * p ; Por que estamos usando int ? Porque apontadores em C sabem o tipo da vari\u00e1vel para a qual apontam , portanto esse tipo deve estar na declara\u00e7\u00e3o. Assim, a combina\u00e7\u00e3o de int seguido por * representa a declara\u00e7\u00e3o de um apontador para vari\u00e1vel inteira. Dif\u00edcil lembrar? Ent\u00e3o note que essa sintaxe \u00e9 totalmente coerente com a regra de ouro! A declara\u00e7\u00e3o int v significa \" v \u00e9 inteira\", enquanto a declara\u00e7\u00e3o int *p significa \"vari\u00e1vel apontada por p \u00e9 inteira\". Vamos agora armazenar o endere\u00e7o de v em p , reproduzindo a situa\u00e7\u00e3o da figura. int v ; int * p ; v = 5 ; p = & v ; Esse c\u00f3digo faz sentido para voc\u00ea? Vejamos se voc\u00ea est\u00e1 entendendo... Question Adicionar v = &5 ao exemplo acima seria v\u00e1lido? Question Adicionar v = p ao exemplo acima seria v\u00e1lido? Question Adicionar v = &p ao exemplo acima seria v\u00e1lido? Question Adicionar p = 5 ao exemplo acima seria v\u00e1lido? Question Adicionar p = &5 ao exemplo acima seria v\u00e1lido? Question Adicionar p = v ao exemplo acima seria v\u00e1lido? Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Agora vejam como o exemplo abaixo \u00e9 interessante. int v ; int * p ; v = 5 ; p = & v ; * p = 10 ; printf ( \"%d\" , v ); Question Qual \u00e9 a sa\u00edda desse exemplo? Pense na regra de ouro. Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores. Resposta A sa\u00edda \u00e9 10 , pois a linha *p = 10 , pela regra de ouro, pode ser lida como \"vari\u00e1vel apontada por p recebe 10 \". E qual \u00e9 a vari\u00e1vel apontada por p ? De fato, podemos usar *p como sin\u00f4nimo de v ao longo do c\u00f3digo. int v ; int * p ; v = 5 ; p = & v ; printf ( \"%d\" , * p ); Obviamente, esse uso s\u00f3 \u00e9 v\u00e1lido a partir do momento em que p recebe o endere\u00e7o de v . Antes de receber a primeira atribui\u00e7\u00e3o, p guarda lixo de mem\u00f3ria, como qualquer vari\u00e1vel. A \u00danica Exce\u00e7\u00e3o \u00b6 A \u00fanica exce\u00e7\u00e3o \u00e0 regra de ouro \u00e9 a situa\u00e7\u00e3o na qual o apontador \u00e9 inicializado na declara\u00e7\u00e3o. int v = 5 ; int * p = & v ; Nesse caso, a regra \u00e9 coerente com a declara\u00e7\u00e3o, mas n\u00e3o \u00e9 coerente com a atribui\u00e7\u00e3o. Quem recebe o endere\u00e7o de v \u00e9 p e n\u00e3o a vari\u00e1vel apontada por p . Ali\u00e1s, nesse momento, nem existe uma vari\u00e1vel apontada por p , j\u00e1 que p est\u00e1 com lixo de mem\u00f3ria. Mas essa \u00e9 a \u00fanica exce\u00e7\u00e3o com a qual voc\u00ea precisa se preocupar! Aplica\u00e7\u00e3o de Apontadores \u00b6 Uma aplica\u00e7\u00e3o comum de apontadores \u00e9 seu uso para contornar o fato de que o return de uma fun\u00e7\u00e3o devolve um \u00fanico valor. Considere a fun\u00e7\u00e3o abaixo, que calcula ao mesmo tempo a soma e a subtra\u00e7\u00e3o de dois inteiros. Essa fun\u00e7\u00e3o est\u00e1 errada , pois o return de dois valores separados por v\u00edrgula \u00e9 permitido em Python mas n\u00e3o em C. Apenas um valor pode ser devolvido em C. int sum_sub ( int a , int b ) { int sum = a + b ; int sub = a - b ; return sum , sub ; // oops... } Para contornar isso, podemos fazer uma fun\u00e7\u00e3o que n\u00e3o devolve nada, ou seja \u00e9 do tipo void , mas escreve a resposta em duas vari\u00e1veis cujos endere\u00e7os s\u00e3o recebidos como par\u00e2metros . void sum_sub ( int a , int b , int * psum , int * psub ) { * psum = a + b ; * psub = a - b ; } Entender o uso dos s\u00edmbolos * acima n\u00e3o deveria ser um problema se voc\u00ea absorveu bem a regra de ouro! Warning Sim, \u00e9 feio. Muito feio. Mas funciona. Repare que chamamos os par\u00e2metros de psum e psub em vez de sum e sub . N\u00e3o faria sentido chamar de sum e sub , pois eles n\u00e3o armazenam os resultados em si e sim os endere\u00e7os das vari\u00e1veis onde eles devem ser armazenados. Example Escreva um programa completo que: usa scanf para ler dois inteiros dados pelo usu\u00e1rio; usa sum_sub para calcular a soma e a subtra\u00e7\u00e3o desses dois inteiros; usa printf para mostrar os dois resultados. Example Escreva um programa completo que: usa scanf para ler dois inteiros dados pelo usu\u00e1rio; supondo que os dois inteiros representam a altura e a largura de um ret\u00e2ngulo, usa uma fun\u00e7\u00e3o para calcular o per\u00edmetro e a \u00e1rea desse ret\u00e2ngulo; usa printf para mostrar os dois resultados. Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Endere\u00e7os e apontadores s\u00e3o considerados conceitos particularmente dif\u00edceis de entender para quem est\u00e1 aprendendo C pela primeira vez. Mantenha sempre a regra de ouro em mente para auxiliar nesse processo. Structs \u00b6 Outro conceito introduzido neste guia \u00e9 o de struct . Trata-se de um recurso que responde a uma das d\u00favidas mais antigas da humanidade: como podemos armazenar m\u00faltiplos valores em uma \u00fanica vari\u00e1vel ? (meu conhecimento de hist\u00f3ria talvez seja um pouco question\u00e1vel) Structs s\u00e3o tipos compostos que armazenam m\u00faltiplos valores. Para voc\u00eas que j\u00e1 aprenderam orienta\u00e7\u00e3o a objetos, pode-se dizer que eles s\u00e3o mais ou menos como \"objetos sem m\u00e9todos, apenas atributos\". Suponha por exemplo que, para um programa de geometria anal\u00edtica, queremos definir um tipo que representa um ponto do plano cartesiano e, portanto, possui dois valores: a coordenada horizontal e a coordenada vertical. Declarar um struct que representa esse tipo \u00e9 mais ou menos simples. struct ponto { int x ; int y ; }; Dizemos \"mais ou menos\" por causa de dois detalhes chatos: o primeiro \u00e9 esse maldito ponto e v\u00edrgula no final, que voc\u00ea com certeza vai esquecer em v\u00e1rios momentos da vida. O segundo \u00e9 o fato de que essa declara\u00e7\u00e3o n\u00e3o cria um tipo chamado ponto , mas sim um tipo chamado struct ponto . Ou seja, para declarar uma vari\u00e1vel desse tipo novo precisamos escrever struct ponto p ; o que \u00e9 um tanto quanto verborr\u00e1gico. Contra o primeiro detalhe n\u00e3o podemos fazer muita coisa, mas contra o segundo existe um recurso muito \u00fatil em C que \u00e9 o typedef . Esse recurso nos permite criar \"apelidos\" para tipos. Assim, podemos reescrever a declara\u00e7\u00e3o do struct da seguinte forma typedef struct { int x ; int y ; } ponto ; que significa \"struct an\u00f4nimo com apelido ponto \". Agora sim, para declarar uma vari\u00e1vel desse tipo novo podemos escrever simplesmente ponto p ; E como usar essa vari\u00e1vel? Basta usar o operador . para acessar seus valores, como em objetos Java. p . x = 10 ; p . y = 20 ; scanf ( \"%d\" , & p . x ); scanf ( \"%d\" , & p . y ); printf ( \"%d\" , p . x ); printf ( \"%d\" , p . y ); Example Reescreva a fun\u00e7\u00e3o de duas aulas atr\u00e1s para calcular a dist\u00e2ncia de Manhattan entre dois pontos. Mas, agora que temos o struct acima, a fun\u00e7\u00e3o deve receber duas vari\u00e1veis do tipo ponto em vez de receber quatro vari\u00e1veis do tipo int . Example Escreva um programa completo que: usa scanf para ler quatro inteiros dados pelo usu\u00e1rio; supondo que esses inteiros representam as coordenadas de dois pontos cartesianos, usa a fun\u00e7\u00e3o anterior para calcular a dist\u00e2ncia de Manhattan; usa printf para mostrar o resultado. Example Refa\u00e7a os dois exerc\u00edcios anteriores, substituindo a dist\u00e2ncia de Manhattan pela dist\u00e2ncia Euclidiana . (pesquise) Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Apontadores para Structs \u00b6 Quando misturamos os conceitos de apontador e struct, algo que tamb\u00e9m ser\u00e1 feito em Desafios de Programa\u00e7\u00e3o , a sintaxe vira um pesadelo cr\u00edptico. ponto p ; ponto * pp ; pp = & p ; ( * pp ). x = 10 ; ( * pp ). y = 20 ; Pare. Respire. N\u00e3o continue a ler at\u00e9 aceitar que o c\u00f3digo acima faz sentido. Lembre da regra de ouro. Question Por que pp.x n\u00e3o faria sentido no exemplo acima? Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores. Felizmente, os criadores do C perceberam que a sintaxe fica meio pesada nesse caso e adicionaram o operador \"setinha\" ( -> ) para ajudar. Grosso modo, esse operador significa \"operador . , mas em rela\u00e7\u00e3o \u00e0 vari\u00e1vel apontada\". Ou seja, o trecho ( * pp ). x = 10 ; ( * pp ). y = 20 ; pode ser substitu\u00eddo pelo trecho pp -> x = 10 ; pp -> y = 20 ; Pare e respire de novo. Question Por que p->x n\u00e3o faria sentido no exemplo acima? Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Example Escreva uma fun\u00e7\u00e3o int medio ( ponto a , ponto b , ponto * m ) que recebe dois pontos e o endere\u00e7o de um terceiro ponto. Essa fun\u00e7\u00e3o deve calcular o ponto m\u00e9dio dos dois pontos e escrever o resultado desse c\u00e1lculo no terceiro. Simples, n\u00e3o? Por\u00e9m, h\u00e1 um detalhe: essa fun\u00e7\u00e3o deve considerar inv\u00e1lido o caso em que os dois pontos s\u00e3o exatamente iguais . Reparou que, apesar de devolver a resposta via apontador, a fun\u00e7\u00e3o \u00e9 do tipo int ? \u00c9 porque ela deve devolver um c\u00f3digo indicando se o caso foi v\u00e1lido ou n\u00e3o. Se os dois pontos s\u00e3o iguais, ela deve devolver 0 e n\u00e3o escrever nada no terceiro. Se os dois pontos s\u00e3o diferentes, ela deve devolver 1 e escrever o resultado no terceiro. Warning N\u00e3o considerem terminado antes de validar suas respostas com um dos professores.","title":"Lab 5 - Ponteiros e `structs`"},{"location":"Lab5/#lab-5-ponteiros-e-structs","text":"Info Por favor, fa\u00e7am esta atividade em dupla e lembrem das regras. Os enunciados de programa\u00e7\u00e3o dizem \"o que\" a fun\u00e7\u00e3o/programa deve fazer, mas n\u00e3o dizem \"como\" deve fazer. N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio de programa\u00e7\u00e3o, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo.","title":"Lab 5 - Ponteiros e structs"},{"location":"Lab5/#introducao","text":"Podemos dizer que praticamente todos os conceitos vistos at\u00e9 agora s\u00e3o adapta\u00e7\u00f5es de conceitos vistos anteriormente em Python e Java . Neste guia, finalmente exploramos alguns conceitos \"exclusivos\" de C e outras linguagens de baixo n\u00edvel. Para introduzir o primeiro deles, vamos come\u00e7ar com uma pergunta. Question Considerando o que vimos anteriormente sobre scanf , passagem por valor e passagem por refer\u00eancia , porque a chamada scanf ( \"%d\" , & n ); n\u00e3o funcionaria sem o & ? Pode parecer estranho, mas voc\u00ea n\u00e3o precisa saber a defini\u00e7\u00e3o de & para poder responder! Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores.","title":"Introdu\u00e7\u00e3o"},{"location":"Lab5/#enderecos","text":"Como vimos anteriormente, os conjuntos de vari\u00e1veis de duas fun\u00e7\u00f5es diferentes s\u00e3o totalmente separados. Ou seja, no exemplo abaixo, void foo ( int n ) { n ++ ; } int bar () { int n = 0 ; foo ( n ); return n ; } a fun\u00e7\u00e3o bar devolve 0 , pois a vari\u00e1vel n de foo \u00e9 diferente da vari\u00e1vel n de bar , apesar das duas terem o mesmo nome. Cabe enfatizar que \u00e9 bom que esse seja o comportamento padr\u00e3o! Geralmente queremos evitar situa\u00e7\u00f5es nas quais uma fun\u00e7\u00e3o altera vari\u00e1veis de outra fun\u00e7\u00e3o. Essas situa\u00e7\u00f5es s\u00e3o conhecidas como efeitos colaterais e costumam ser indesejadas por tornarem o c\u00f3digo mais imprevis\u00edvel, aumentarem a probabilidade de bugs e dificultarem testes. No entanto, se soubermos muito bem o que estamos fazendo, efeitos colaterais podem ser \u00fateis. O scanf \u00e9 o exemplo \u00f3bvio disso! Ent\u00e3o vamos mostrar como permiti-los. O problema do exemplo anterior \u00e9 que o nome de uma vari\u00e1vel \u00e9 um identificador local , ou seja, vale apenas dentro do escopo da fun\u00e7\u00e3o na qual a vari\u00e1vel foi declarada. Mas a vari\u00e1vel tamb\u00e9m possui um identificador global que \u00e9 seu endere\u00e7o . Se uma fun\u00e7\u00e3o sabe o endere\u00e7o de uma vari\u00e1vel, essa vari\u00e1vel pode ser modificada pela fun\u00e7\u00e3o mesmo se n\u00e3o foi declarada dentro dela. Para entender melhor o conceito de endere\u00e7o, basta pensar na mem\u00f3ria como um \"vetorz\u00e3o\" e na vari\u00e1vel como um elemento desse \"vetorz\u00e3o\". O endere\u00e7o, nessa analogia, seria o \u00edndice desse elemento. E como obtemos o endere\u00e7o de uma vari\u00e1vel? Basta usar o operador un\u00e1rio & . Isso explica o que acontece em rela\u00e7\u00e3o ao scanf : o que a fun\u00e7\u00e3o recebe n\u00e3o \u00e9 o valor de uma vari\u00e1vel, e sim seu endere\u00e7o. Assim, ganha o poder de escrever nela o valor digitado pelo usu\u00e1rio. Ent\u00e3o lembre-se: sempre que encontrar o s\u00edmbolo & , leia como se ele fosse a express\u00e3o \"endere\u00e7o de\" . & a // l\u00ea-se \"endere\u00e7o de a\" & b // l\u00ea-se \"endere\u00e7o de b\" & abobrinha // l\u00ea-se \"endere\u00e7o de abobrinha\" Mas para podermos passar endere\u00e7os para l\u00e1 e para c\u00e1, precisamos de vari\u00e1veis especiais que guardam endere\u00e7os. Essas vari\u00e1veis s\u00e3o conhecidas como apontadores ou ponteiros ( pointers em ingl\u00eas) e indicadas pelo s\u00edmbolo * . Antes de dar mais detalhes, vamos dar uma dica simples e valiosa em rela\u00e7\u00e3o a esse s\u00edmbolo.","title":"Endere\u00e7os"},{"location":"Lab5/#a-regra-de-ouro","text":"Dizemos que um apontador p aponta para uma vari\u00e1vel v se o endere\u00e7o de v est\u00e1 armazenado em p . Visualmente, podemos representar isso da seguinte forma: Esta figura \u00e9 uma representa\u00e7\u00e3o visual de p apontar para v . Nesse caso, v \u00e9 uma vari\u00e1vel inteira cujo valor \u00e9 5 e p \u00e9 um apontador cujo valor \u00e9 o endere\u00e7o de v . Acostume-se com essa representa\u00e7\u00e3o visual, ali\u00e1s, pois ela ser\u00e1 muito usada em Desafios de Programa\u00e7\u00e3o ! Mas o que realmente queremos enfatizar aqui \u00e9 que, a partir dessa terminologia, podemos derivar uma pequena regra que ajuda muito a compreender c\u00f3digos que usam * no contexto de endere\u00e7os e apontadores: sempre que encontrar o s\u00edmbolo * , leia como se ele fosse a express\u00e3o \"vari\u00e1vel apontada por\" . Sem contexto essa regra parece estranha, ent\u00e3o vamos aos exemplos!","title":"A Regra de Ouro"},{"location":"Lab5/#apontadores","text":"Vamos declarar o apontador p do exemplo acima. int * p ; Por que estamos usando int ? Porque apontadores em C sabem o tipo da vari\u00e1vel para a qual apontam , portanto esse tipo deve estar na declara\u00e7\u00e3o. Assim, a combina\u00e7\u00e3o de int seguido por * representa a declara\u00e7\u00e3o de um apontador para vari\u00e1vel inteira. Dif\u00edcil lembrar? Ent\u00e3o note que essa sintaxe \u00e9 totalmente coerente com a regra de ouro! A declara\u00e7\u00e3o int v significa \" v \u00e9 inteira\", enquanto a declara\u00e7\u00e3o int *p significa \"vari\u00e1vel apontada por p \u00e9 inteira\". Vamos agora armazenar o endere\u00e7o de v em p , reproduzindo a situa\u00e7\u00e3o da figura. int v ; int * p ; v = 5 ; p = & v ; Esse c\u00f3digo faz sentido para voc\u00ea? Vejamos se voc\u00ea est\u00e1 entendendo... Question Adicionar v = &5 ao exemplo acima seria v\u00e1lido? Question Adicionar v = p ao exemplo acima seria v\u00e1lido? Question Adicionar v = &p ao exemplo acima seria v\u00e1lido? Question Adicionar p = 5 ao exemplo acima seria v\u00e1lido? Question Adicionar p = &5 ao exemplo acima seria v\u00e1lido? Question Adicionar p = v ao exemplo acima seria v\u00e1lido? Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Agora vejam como o exemplo abaixo \u00e9 interessante. int v ; int * p ; v = 5 ; p = & v ; * p = 10 ; printf ( \"%d\" , v ); Question Qual \u00e9 a sa\u00edda desse exemplo? Pense na regra de ouro. Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores. Resposta A sa\u00edda \u00e9 10 , pois a linha *p = 10 , pela regra de ouro, pode ser lida como \"vari\u00e1vel apontada por p recebe 10 \". E qual \u00e9 a vari\u00e1vel apontada por p ? De fato, podemos usar *p como sin\u00f4nimo de v ao longo do c\u00f3digo. int v ; int * p ; v = 5 ; p = & v ; printf ( \"%d\" , * p ); Obviamente, esse uso s\u00f3 \u00e9 v\u00e1lido a partir do momento em que p recebe o endere\u00e7o de v . Antes de receber a primeira atribui\u00e7\u00e3o, p guarda lixo de mem\u00f3ria, como qualquer vari\u00e1vel.","title":"Apontadores"},{"location":"Lab5/#a-unica-excecao","text":"A \u00fanica exce\u00e7\u00e3o \u00e0 regra de ouro \u00e9 a situa\u00e7\u00e3o na qual o apontador \u00e9 inicializado na declara\u00e7\u00e3o. int v = 5 ; int * p = & v ; Nesse caso, a regra \u00e9 coerente com a declara\u00e7\u00e3o, mas n\u00e3o \u00e9 coerente com a atribui\u00e7\u00e3o. Quem recebe o endere\u00e7o de v \u00e9 p e n\u00e3o a vari\u00e1vel apontada por p . Ali\u00e1s, nesse momento, nem existe uma vari\u00e1vel apontada por p , j\u00e1 que p est\u00e1 com lixo de mem\u00f3ria. Mas essa \u00e9 a \u00fanica exce\u00e7\u00e3o com a qual voc\u00ea precisa se preocupar!","title":"A \u00danica Exce\u00e7\u00e3o"},{"location":"Lab5/#aplicacao-de-apontadores","text":"Uma aplica\u00e7\u00e3o comum de apontadores \u00e9 seu uso para contornar o fato de que o return de uma fun\u00e7\u00e3o devolve um \u00fanico valor. Considere a fun\u00e7\u00e3o abaixo, que calcula ao mesmo tempo a soma e a subtra\u00e7\u00e3o de dois inteiros. Essa fun\u00e7\u00e3o est\u00e1 errada , pois o return de dois valores separados por v\u00edrgula \u00e9 permitido em Python mas n\u00e3o em C. Apenas um valor pode ser devolvido em C. int sum_sub ( int a , int b ) { int sum = a + b ; int sub = a - b ; return sum , sub ; // oops... } Para contornar isso, podemos fazer uma fun\u00e7\u00e3o que n\u00e3o devolve nada, ou seja \u00e9 do tipo void , mas escreve a resposta em duas vari\u00e1veis cujos endere\u00e7os s\u00e3o recebidos como par\u00e2metros . void sum_sub ( int a , int b , int * psum , int * psub ) { * psum = a + b ; * psub = a - b ; } Entender o uso dos s\u00edmbolos * acima n\u00e3o deveria ser um problema se voc\u00ea absorveu bem a regra de ouro! Warning Sim, \u00e9 feio. Muito feio. Mas funciona. Repare que chamamos os par\u00e2metros de psum e psub em vez de sum e sub . N\u00e3o faria sentido chamar de sum e sub , pois eles n\u00e3o armazenam os resultados em si e sim os endere\u00e7os das vari\u00e1veis onde eles devem ser armazenados. Example Escreva um programa completo que: usa scanf para ler dois inteiros dados pelo usu\u00e1rio; usa sum_sub para calcular a soma e a subtra\u00e7\u00e3o desses dois inteiros; usa printf para mostrar os dois resultados. Example Escreva um programa completo que: usa scanf para ler dois inteiros dados pelo usu\u00e1rio; supondo que os dois inteiros representam a altura e a largura de um ret\u00e2ngulo, usa uma fun\u00e7\u00e3o para calcular o per\u00edmetro e a \u00e1rea desse ret\u00e2ngulo; usa printf para mostrar os dois resultados. Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Endere\u00e7os e apontadores s\u00e3o considerados conceitos particularmente dif\u00edceis de entender para quem est\u00e1 aprendendo C pela primeira vez. Mantenha sempre a regra de ouro em mente para auxiliar nesse processo.","title":"Aplica\u00e7\u00e3o de Apontadores"},{"location":"Lab5/#structs","text":"Outro conceito introduzido neste guia \u00e9 o de struct . Trata-se de um recurso que responde a uma das d\u00favidas mais antigas da humanidade: como podemos armazenar m\u00faltiplos valores em uma \u00fanica vari\u00e1vel ? (meu conhecimento de hist\u00f3ria talvez seja um pouco question\u00e1vel) Structs s\u00e3o tipos compostos que armazenam m\u00faltiplos valores. Para voc\u00eas que j\u00e1 aprenderam orienta\u00e7\u00e3o a objetos, pode-se dizer que eles s\u00e3o mais ou menos como \"objetos sem m\u00e9todos, apenas atributos\". Suponha por exemplo que, para um programa de geometria anal\u00edtica, queremos definir um tipo que representa um ponto do plano cartesiano e, portanto, possui dois valores: a coordenada horizontal e a coordenada vertical. Declarar um struct que representa esse tipo \u00e9 mais ou menos simples. struct ponto { int x ; int y ; }; Dizemos \"mais ou menos\" por causa de dois detalhes chatos: o primeiro \u00e9 esse maldito ponto e v\u00edrgula no final, que voc\u00ea com certeza vai esquecer em v\u00e1rios momentos da vida. O segundo \u00e9 o fato de que essa declara\u00e7\u00e3o n\u00e3o cria um tipo chamado ponto , mas sim um tipo chamado struct ponto . Ou seja, para declarar uma vari\u00e1vel desse tipo novo precisamos escrever struct ponto p ; o que \u00e9 um tanto quanto verborr\u00e1gico. Contra o primeiro detalhe n\u00e3o podemos fazer muita coisa, mas contra o segundo existe um recurso muito \u00fatil em C que \u00e9 o typedef . Esse recurso nos permite criar \"apelidos\" para tipos. Assim, podemos reescrever a declara\u00e7\u00e3o do struct da seguinte forma typedef struct { int x ; int y ; } ponto ; que significa \"struct an\u00f4nimo com apelido ponto \". Agora sim, para declarar uma vari\u00e1vel desse tipo novo podemos escrever simplesmente ponto p ; E como usar essa vari\u00e1vel? Basta usar o operador . para acessar seus valores, como em objetos Java. p . x = 10 ; p . y = 20 ; scanf ( \"%d\" , & p . x ); scanf ( \"%d\" , & p . y ); printf ( \"%d\" , p . x ); printf ( \"%d\" , p . y ); Example Reescreva a fun\u00e7\u00e3o de duas aulas atr\u00e1s para calcular a dist\u00e2ncia de Manhattan entre dois pontos. Mas, agora que temos o struct acima, a fun\u00e7\u00e3o deve receber duas vari\u00e1veis do tipo ponto em vez de receber quatro vari\u00e1veis do tipo int . Example Escreva um programa completo que: usa scanf para ler quatro inteiros dados pelo usu\u00e1rio; supondo que esses inteiros representam as coordenadas de dois pontos cartesianos, usa a fun\u00e7\u00e3o anterior para calcular a dist\u00e2ncia de Manhattan; usa printf para mostrar o resultado. Example Refa\u00e7a os dois exerc\u00edcios anteriores, substituindo a dist\u00e2ncia de Manhattan pela dist\u00e2ncia Euclidiana . (pesquise) Warning N\u00e3o continue antes de validar suas respostas com um dos professores.","title":"Structs"},{"location":"Lab5/#apontadores-para-structs","text":"Quando misturamos os conceitos de apontador e struct, algo que tamb\u00e9m ser\u00e1 feito em Desafios de Programa\u00e7\u00e3o , a sintaxe vira um pesadelo cr\u00edptico. ponto p ; ponto * pp ; pp = & p ; ( * pp ). x = 10 ; ( * pp ). y = 20 ; Pare. Respire. N\u00e3o continue a ler at\u00e9 aceitar que o c\u00f3digo acima faz sentido. Lembre da regra de ouro. Question Por que pp.x n\u00e3o faria sentido no exemplo acima? Warning N\u00e3o v\u00e1 para a pr\u00f3xima p\u00e1gina antes de validar suas respostas com um dos professores. Felizmente, os criadores do C perceberam que a sintaxe fica meio pesada nesse caso e adicionaram o operador \"setinha\" ( -> ) para ajudar. Grosso modo, esse operador significa \"operador . , mas em rela\u00e7\u00e3o \u00e0 vari\u00e1vel apontada\". Ou seja, o trecho ( * pp ). x = 10 ; ( * pp ). y = 20 ; pode ser substitu\u00eddo pelo trecho pp -> x = 10 ; pp -> y = 20 ; Pare e respire de novo. Question Por que p->x n\u00e3o faria sentido no exemplo acima? Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Example Escreva uma fun\u00e7\u00e3o int medio ( ponto a , ponto b , ponto * m ) que recebe dois pontos e o endere\u00e7o de um terceiro ponto. Essa fun\u00e7\u00e3o deve calcular o ponto m\u00e9dio dos dois pontos e escrever o resultado desse c\u00e1lculo no terceiro. Simples, n\u00e3o? Por\u00e9m, h\u00e1 um detalhe: essa fun\u00e7\u00e3o deve considerar inv\u00e1lido o caso em que os dois pontos s\u00e3o exatamente iguais . Reparou que, apesar de devolver a resposta via apontador, a fun\u00e7\u00e3o \u00e9 do tipo int ? \u00c9 porque ela deve devolver um c\u00f3digo indicando se o caso foi v\u00e1lido ou n\u00e3o. Se os dois pontos s\u00e3o iguais, ela deve devolver 0 e n\u00e3o escrever nada no terceiro. Se os dois pontos s\u00e3o diferentes, ela deve devolver 1 e escrever o resultado no terceiro. Warning N\u00e3o considerem terminado antes de validar suas respostas com um dos professores.","title":"Apontadores para Structs"},{"location":"Lab6/","text":"Lab 6 - juntando tudo \u00b6 Info Este roteiro n\u00e3o apresenta nenhum conceito novo. Voc\u00eas podem faz\u00ea-lo apenas com o que j\u00e1 foi apresentado nos roteiros anteriores. Se voc\u00ea est\u00e1 precisando consultar materiais extras \u00e9 um sinal de que sua solu\u00e7\u00e3o \u00e9 complicada demais. Vamos neste roteiro revisar os conceitos dos dois roteiros anteriores fazendo modifica\u00e7\u00f5es para tornar seu programa mais leg\u00edvel e organizado. Example Crie uma estrurura imagem para guardar largura, altura e a matriz da imagem. Voc\u00ea pode supor que ela tem tamanho m\u00e1ximo 640\\times 480 640\\times 480 . Example Modifique sua fun\u00e7\u00e3o le_imagem que carrega o conte\u00fado de uma imagem do terminal e escreve em uma estrutura imagem . Quais par\u00e2metros sua fun\u00e7\u00e3o recebe? Example Modifique sua fun\u00e7\u00e3o escreve_imagem para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Example Modifique sua fun\u00e7\u00e3o limiar para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Warning Valide sua implementa\u00e7\u00e3o com os professores antes de seguir. Exerc\u00edcios avan\u00e7ados \u00b6 Example Crop : crie uma fun\u00e7\u00e3o crop que corta uma imagem. Sua fun\u00e7\u00e3o dever\u00e1 receber dois tipos imagem : um para a imagem original e outra para a imagem cortada. Quais par\u00e2metros sua fun\u00e7\u00e3o deve receber? Voc\u00ea deve usar apontadores? Example Borramento : crie uma fun\u00e7\u00e3o blur que faz o borramento de uma imagem. Ela dever\u00e1 receber dois tipos imagem : um contendo a imagem original e um que receber\u00e1 a imagem processada. Para borrar a imagem compute, para cada ponto, a m\u00e9dia entre seu valor e o valor de seus vizinhos (incluindo diagonais). Example Detector de bordas : voc\u00ea pode detectar bordas em uma imagem computando, para cada ponto, a diferen\u00e7a entre 4 vezes seu valor e o valor dos seus vizinhos. Warning Valide visualmente cada exerc\u00edcio antes de prosseguir.","title":"Lab 6 - juntando tudo"},{"location":"Lab6/#lab-6-juntando-tudo","text":"Info Este roteiro n\u00e3o apresenta nenhum conceito novo. Voc\u00eas podem faz\u00ea-lo apenas com o que j\u00e1 foi apresentado nos roteiros anteriores. Se voc\u00ea est\u00e1 precisando consultar materiais extras \u00e9 um sinal de que sua solu\u00e7\u00e3o \u00e9 complicada demais. Vamos neste roteiro revisar os conceitos dos dois roteiros anteriores fazendo modifica\u00e7\u00f5es para tornar seu programa mais leg\u00edvel e organizado. Example Crie uma estrurura imagem para guardar largura, altura e a matriz da imagem. Voc\u00ea pode supor que ela tem tamanho m\u00e1ximo 640\\times 480 640\\times 480 . Example Modifique sua fun\u00e7\u00e3o le_imagem que carrega o conte\u00fado de uma imagem do terminal e escreve em uma estrutura imagem . Quais par\u00e2metros sua fun\u00e7\u00e3o recebe? Example Modifique sua fun\u00e7\u00e3o escreve_imagem para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Example Modifique sua fun\u00e7\u00e3o limiar para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Warning Valide sua implementa\u00e7\u00e3o com os professores antes de seguir.","title":"Lab 6 - juntando tudo"},{"location":"Lab6/#exercicios-avancados","text":"Example Crop : crie uma fun\u00e7\u00e3o crop que corta uma imagem. Sua fun\u00e7\u00e3o dever\u00e1 receber dois tipos imagem : um para a imagem original e outra para a imagem cortada. Quais par\u00e2metros sua fun\u00e7\u00e3o deve receber? Voc\u00ea deve usar apontadores? Example Borramento : crie uma fun\u00e7\u00e3o blur que faz o borramento de uma imagem. Ela dever\u00e1 receber dois tipos imagem : um contendo a imagem original e um que receber\u00e1 a imagem processada. Para borrar a imagem compute, para cada ponto, a m\u00e9dia entre seu valor e o valor de seus vizinhos (incluindo diagonais). Example Detector de bordas : voc\u00ea pode detectar bordas em uma imagem computando, para cada ponto, a diferen\u00e7a entre 4 vezes seu valor e o valor dos seus vizinhos. Warning Valide visualmente cada exerc\u00edcio antes de prosseguir.","title":"Exerc\u00edcios avan\u00e7ados"},{"location":"Lab7/","text":"Lab 7 - Manipulando bits \u00b6 Warning Esse lab deve ser realizado no Linux. Na linguagem C a menor unidade de armazenamento existente \u00e9 a do char , que possui 8 bits. Mesmo sendo considerada de 'baixo n\u00edvel' n\u00e3o possu\u00edmos uma maneira 'built-in' na linguagem de armazenar e/ou processar um \u00fanico bit . Alguns compiladores para sistemas embarcados fornecem um tipo bit, por\u00e9m isso \u00e9 exclusivo dessas plataformas. Note No ARM possu\u00edmos os seguintes tipos definidos: type Size in bits natural alignment in bytes char 8 1 (byte-aligned) short 16 2 (halfword-aligned) int 32 4 (word-aligned) long 32 4 (word-aligned) long long 64 8 (doubleword-aligned) float 32 4 (word-aligned) double 64 8 (doubleword-aligned) long double 64 8 (doubleword-aligned) All pointers 32 4 (word-aligned) _Bool (C only[a]) 8 1 (byte-aligned) [a] stdbool.h can be used to define the bool macro in C . fonte: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Babfcgfc.html A manipula\u00e7\u00e3o de bits \u00e9 muito importante quando utilizamos a linguagem para: interagir com o hardware; verificar e manipular tipos; otimiza\u00e7\u00f5es. Os objetivos deste lab s\u00e3o obter familiaridade com as opera\u00e7\u00f5es bitwise em C aplic\u00e1-las para resolver problemas envolvendo m\u00faltiplas opera\u00e7\u00f5es usar m\u00e1scaras de bits para sets bits espec\u00edficos em um inteiro 32 bits usar m\u00e1scaras de bits para checar se bits espec\u00edficos est\u00e3o ligados Come\u00e7ando \u00b6 O lab est\u00e1 localizado na pasta: code/07-bits-1/ e cont\u00e9m os seguintes arquivos: exercicios.c : Arquivo em C que deve ser editado Makefile : Arquivo de configura\u00e7\u00e3o e execu\u00e7\u00e3o do lab O lab possui teste unit\u00e1rio para as fun\u00e7\u00f5es que dever\u00e3o ser desenvolvidas, para executar os testes basta abrir o terminal na pasta e executar o comando make . cd code/07-bits-1/ make Voc\u00ea deve implementar as fun\u00e7\u00f5es de forma sequencial, sendo a primeira a que aparece no come\u00e7o do arquivo exercicio.c . Leia os coment\u00e1rios do c\u00f3digo para entender. Tip Teste o c\u00f3digo para cada fun\u00e7\u00e3o feita, n\u00e3o deixe acumular. Submetendo \u00b6 Ao terminal o lab voc\u00ea deve dar um push no seu reposit\u00f3rio. Warning Todos os testes devem estar passando para considerar a entrega conclu\u00edda.","title":"Lab 7 - Manipulando bits"},{"location":"Lab7/#lab-7-manipulando-bits","text":"Warning Esse lab deve ser realizado no Linux. Na linguagem C a menor unidade de armazenamento existente \u00e9 a do char , que possui 8 bits. Mesmo sendo considerada de 'baixo n\u00edvel' n\u00e3o possu\u00edmos uma maneira 'built-in' na linguagem de armazenar e/ou processar um \u00fanico bit . Alguns compiladores para sistemas embarcados fornecem um tipo bit, por\u00e9m isso \u00e9 exclusivo dessas plataformas. Note No ARM possu\u00edmos os seguintes tipos definidos: type Size in bits natural alignment in bytes char 8 1 (byte-aligned) short 16 2 (halfword-aligned) int 32 4 (word-aligned) long 32 4 (word-aligned) long long 64 8 (doubleword-aligned) float 32 4 (word-aligned) double 64 8 (doubleword-aligned) long double 64 8 (doubleword-aligned) All pointers 32 4 (word-aligned) _Bool (C only[a]) 8 1 (byte-aligned) [a] stdbool.h can be used to define the bool macro in C . fonte: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Babfcgfc.html A manipula\u00e7\u00e3o de bits \u00e9 muito importante quando utilizamos a linguagem para: interagir com o hardware; verificar e manipular tipos; otimiza\u00e7\u00f5es. Os objetivos deste lab s\u00e3o obter familiaridade com as opera\u00e7\u00f5es bitwise em C aplic\u00e1-las para resolver problemas envolvendo m\u00faltiplas opera\u00e7\u00f5es usar m\u00e1scaras de bits para sets bits espec\u00edficos em um inteiro 32 bits usar m\u00e1scaras de bits para checar se bits espec\u00edficos est\u00e3o ligados","title":"Lab 7 - Manipulando bits"},{"location":"Lab7/#comecando","text":"O lab est\u00e1 localizado na pasta: code/07-bits-1/ e cont\u00e9m os seguintes arquivos: exercicios.c : Arquivo em C que deve ser editado Makefile : Arquivo de configura\u00e7\u00e3o e execu\u00e7\u00e3o do lab O lab possui teste unit\u00e1rio para as fun\u00e7\u00f5es que dever\u00e3o ser desenvolvidas, para executar os testes basta abrir o terminal na pasta e executar o comando make . cd code/07-bits-1/ make Voc\u00ea deve implementar as fun\u00e7\u00f5es de forma sequencial, sendo a primeira a que aparece no come\u00e7o do arquivo exercicio.c . Leia os coment\u00e1rios do c\u00f3digo para entender. Tip Teste o c\u00f3digo para cada fun\u00e7\u00e3o feita, n\u00e3o deixe acumular.","title":"Come\u00e7ando"},{"location":"Lab7/#submetendo","text":"Ao terminal o lab voc\u00ea deve dar um push no seu reposit\u00f3rio. Warning Todos os testes devem estar passando para considerar a entrega conclu\u00edda.","title":"Submetendo"},{"location":"day1-embarcados-parte2/","text":"Embarcados - Parte 2 \u00b6 Melhorando o desempenho \u00b6 Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador. Alterando a frequ\u00eancia de opera\u00e7\u00e3o \u00b6 O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou? Como tudo isso funciona? \u00b6 Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD: Sistema detalhado \u00b6 Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM). microcontrolador \u00b6 Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). . Firmware \u00b6 O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Parte 2"},{"location":"day1-embarcados-parte2/#embarcados-parte-2","text":"","title":"Embarcados - Parte 2"},{"location":"day1-embarcados-parte2/#melhorando-o-desempenho","text":"Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador.","title":"Melhorando o desempenho"},{"location":"day1-embarcados-parte2/#alterando-a-frequencia-de-operacao","text":"O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou?","title":"Alterando a frequ\u00eancia de opera\u00e7\u00e3o"},{"location":"day1-embarcados-parte2/#como-tudo-isso-funciona","text":"Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD:","title":"Como tudo isso funciona?"},{"location":"day1-embarcados-parte2/#sistema-detalhado","text":"Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM).","title":"Sistema detalhado"},{"location":"day1-embarcados-parte2/#microcontrolador","text":"Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). .","title":"microcontrolador"},{"location":"day1-embarcados-parte2/#firmware","text":"O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Firmware"},{"location":"day1-embarcados/","text":"Embarcados - Parte 1 \u00b6 Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro Parte 1 \u00b6 Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows). Conectando o LCD \u00b6 Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB. AtmelStudio \u00b6 Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do 'Labs-de-C': https://github.com/Insper/Labs-de-C/tree/master/day-one/SAME70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: . Compilar e programar \u00b6 A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : . Testando \u00b6 Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Parte 1"},{"location":"day1-embarcados/#embarcados-parte-1","text":"Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro","title":"Embarcados - Parte 1"},{"location":"day1-embarcados/#parte-1","text":"Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows).","title":"Parte 1"},{"location":"day1-embarcados/#conectando-o-lcd","text":"Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB.","title":"Conectando o LCD"},{"location":"day1-embarcados/#atmelstudio","text":"Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do 'Labs-de-C': https://github.com/Insper/Labs-de-C/tree/master/day-one/SAME70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: .","title":"AtmelStudio"},{"location":"day1-embarcados/#compilar-e-programar","text":"A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : .","title":"Compilar e programar"},{"location":"day1-embarcados/#testando","text":"Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Testando"},{"location":"mutirao/","text":"Sobre \u00b6 O mutir\u00e3o C \u00e9 composto de uma 'Super Aula', laborat\u00f3rios e uma avalia\u00e7\u00e3o. O cronograma a ser seguido na primeira semana de aula ser\u00e1: Data Dia Aula Atividade Conceito 10/2 Segunda Sistema HW/SW Super Aula Embarcados Lab1 e Lab2 Introdu\u00e7\u00e3o a C 11/2 Ter\u00e7a Lab3 Compila\u00e7\u00e3o com GCC 12/2 Quarta Desafios Lab4 Array, Strings e Matrizes *Embarcados Lab5 Ponteiro e Structs 13/2 Quinta *Embarcados Lab5 Sistema HW/SW Lab6 Praticando 14/2 Desafios Avalia\u00e7\u00e3o Prova individual *Aulas com metade da turma.","title":"Sobre"},{"location":"mutirao/#sobre","text":"O mutir\u00e3o C \u00e9 composto de uma 'Super Aula', laborat\u00f3rios e uma avalia\u00e7\u00e3o. O cronograma a ser seguido na primeira semana de aula ser\u00e1: Data Dia Aula Atividade Conceito 10/2 Segunda Sistema HW/SW Super Aula Embarcados Lab1 e Lab2 Introdu\u00e7\u00e3o a C 11/2 Ter\u00e7a Lab3 Compila\u00e7\u00e3o com GCC 12/2 Quarta Desafios Lab4 Array, Strings e Matrizes *Embarcados Lab5 Ponteiro e Structs 13/2 Quinta *Embarcados Lab5 Sistema HW/SW Lab6 Praticando 14/2 Desafios Avalia\u00e7\u00e3o Prova individual *Aulas com metade da turma.","title":"Sobre"}]}